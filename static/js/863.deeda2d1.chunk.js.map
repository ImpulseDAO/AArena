{"version":3,"file":"static/js/863.deeda2d1.chunk.js","mappings":"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","sources":["../node_modules/@tanstack/query-core/src/queriesObserver.ts","../node_modules/@tanstack/query-core/src/infiniteQueryObserver.ts","../node_modules/@tanstack/query-core/src/mutationObserver.ts","../node_modules/@tanstack/query-core/src/hydration.ts","../node_modules/@tanstack/react-query/src/useQueries.ts","../node_modules/@tanstack/react-query/src/useSuspenseQuery.ts","../node_modules/@tanstack/react-query/src/useSuspenseInfiniteQuery.ts","../node_modules/@tanstack/react-query/src/useSuspenseQueries.ts","../node_modules/@tanstack/react-query/src/queryOptions.ts","../node_modules/@tanstack/react-query/src/infiniteQueryOptions.ts","../node_modules/@tanstack/react-query/src/HydrationBoundary.tsx","../node_modules/@tanstack/react-query/src/useIsFetching.ts","../node_modules/@tanstack/react-query/src/useMutationState.ts","../node_modules/@tanstack/react-query/src/useMutation.ts","../node_modules/@tanstack/react-query/src/useInfiniteQuery.ts","../node_modules/react-query-kit/src/utils.ts","../node_modules/react-query-kit/src/createBaseQuery.ts","../node_modules/react-query-kit/src/createQuery.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport { replaceEqualDeep } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\n\nfunction difference<T>(array1: Array<T>, array2: Array<T>): Array<T> {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nfunction replaceAt<T>(array: Array<T>, index: number, value: T): Array<T> {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\ntype QueriesObserverListener = (result: Array<QueryObserverResult>) => void\n\nexport interface QueriesObserverOptions<\n  TCombinedResult = Array<QueryObserverResult>,\n> {\n  combine?: (result: Array<QueryObserverResult>) => TCombinedResult\n}\n\nexport class QueriesObserver<\n  TCombinedResult = Array<QueryObserverResult>,\n> extends Subscribable<QueriesObserverListener> {\n  #client: QueryClient\n  #result!: Array<QueryObserverResult>\n  #queries: Array<QueryObserverOptions>\n  #observers: Array<QueryObserver>\n  #options?: QueriesObserverOptions<TCombinedResult>\n  #combinedResult!: TCombinedResult\n\n  constructor(\n    client: QueryClient,\n    queries: Array<QueryObserverOptions>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ) {\n    super()\n\n    this.#client = client\n    this.#queries = queries\n    this.#options = options\n    this.#observers = []\n\n    this.#setResult([])\n    this.setQueries(queries, options)\n  }\n\n  #setResult(value: Array<QueryObserverResult>) {\n    this.#result = value\n    this.#combinedResult = this.#combineResult(value)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: Array<QueryObserverOptions>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.#queries = queries\n    this.#options = options\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers\n\n      const newObserverMatches = this.#findMatchingObservers(this.#queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.#observers = newObservers\n      this.#setResult(newResult)\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n\n      this.#notify()\n    })\n  }\n\n  getCurrentResult(): TCombinedResult {\n    return this.#combinedResult\n  }\n\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.#observers\n  }\n\n  getOptimisticResult(\n    queries: Array<QueryObserverOptions>,\n  ): [\n    rawResult: Array<QueryObserverResult>,\n    combineResult: (r?: Array<QueryObserverResult>) => TCombinedResult,\n    trackResult: () => Array<QueryObserverResult>,\n  ] {\n    const matches = this.#findMatchingObservers(queries)\n    const result = matches.map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n\n    return [\n      result,\n      (r?: Array<QueryObserverResult>) => {\n        return this.#combineResult(r ?? result)\n      },\n      () => {\n        return matches.map((match, index) => {\n          const observerResult = result[index]!\n          return !match.defaultedQueryOptions.notifyOnChangeProps\n            ? match.observer.trackResult(observerResult)\n            : observerResult\n        })\n      },\n    ]\n  }\n\n  #combineResult(input: Array<QueryObserverResult>): TCombinedResult {\n    const combine = this.#options?.combine\n    if (combine) {\n      return replaceEqualDeep(this.#combinedResult, combine(input))\n    }\n    return input as any\n  }\n\n  #findMatchingObservers(\n    queries: Array<QueryObserverOptions>,\n  ): Array<QueryObserverMatch> {\n    const prevObservers = this.#observers\n    const prevObserversMap = new Map(\n      prevObservers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const defaultedQueryOptions = queries.map((options) =>\n      this.#client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: Array<QueryObserverMatch> =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObserversMap.get(defaultedOptions.queryHash)\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = new Set(\n      matchingObservers.map((match) => match.defaultedQueryOptions.queryHash),\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options)\n      const currentObserver = this.#observers.find(\n        (o) => o.options.queryHash === defaultedOptions.queryHash,\n      )\n      return (\n        currentObserver ?? new QueryObserver(this.#client, defaultedOptions)\n      )\n    }\n\n    const newOrReusedObservers: Array<QueryObserverMatch> =\n      unmatchedQueries.map((options) => {\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      })\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  #onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.#observers.indexOf(observer)\n    if (index !== -1) {\n      this.#setResult(replaceAt(this.#result, index, result))\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(this.#result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n","import { QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\nimport type {\n  DefaultError,\n  DefaultedInfiniteQueryObserverOptions,\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions, ObserverFetchOptions } from './queryObserver'\nimport type { Query } from './query'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>,\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  TData,\n  InfiniteData<TQueryData, TPageParam>,\n  TQueryKey\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>,\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions: ObserverFetchOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    super.setOptions(\n      {\n        ...options,\n        behavior: infiniteQueryBehavior(),\n      },\n      notifyOptions,\n    )\n  }\n\n  getOptimisticResult(\n    options: DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    options.behavior = infiniteQueryBehavior()\n    return super.getOptimisticResult(options) as InfiniteQueryObserverResult<\n      TData,\n      TError\n    >\n  }\n\n  fetchNextPage(\n    options?: FetchNextPageOptions,\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'forward' },\n      },\n    })\n  }\n\n  fetchPreviousPage(\n    options?: FetchPreviousPageOptions,\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'backward' },\n      },\n    })\n  }\n\n  protected createResult(\n    query: Query<\n      TQueryFnData,\n      TError,\n      InfiniteData<TQueryData, TPageParam>,\n      TQueryKey\n    >,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = query\n    const result = super.createResult(query, options)\n\n    const { isFetching, isRefetching } = result\n\n    const isFetchingNextPage =\n      isFetching && state.fetchMeta?.fetchMore?.direction === 'forward'\n\n    const isFetchingPreviousPage =\n      isFetching && state.fetchMeta?.fetchMore?.direction === 'backward'\n\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data),\n      hasPreviousPage: hasPreviousPage(options, state.data),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching:\n        isRefetching && !isFetchingNextPage && !isFetchingPreviousPage,\n    }\n  }\n}\n","import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { hashKey, shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<TData, TError, TVariables, TContext> =\n    undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options as\n      | MutationObserverOptions<TData, TError, TVariables, TContext>\n      | undefined\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n    this.#currentMutation?.setOptions(this.options)\n\n    if (\n      prevOptions?.mutationKey &&\n      this.options.mutationKey &&\n      hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)\n    ) {\n      this.reset()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    // reset needs to remove the observer from the mutation because there is no way to \"get it back\"\n    // another mutate call will yield a new mutation!\n    this.#currentMutation?.removeObserver(this)\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TContext>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TContext>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables!\n        const context = this.#currentResult.context\n\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context!)\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context)\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(action.error, variables, context)\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            variables,\n            context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n","import type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type {\n  MutationKey,\n  MutationMeta,\n  MutationOptions,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n} from './types'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  shouldDehydrateMutation?: (mutation: Mutation) => boolean\n  shouldDehydrateQuery?: (query: Query) => boolean\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n  meta?: MutationMeta\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n  meta?: QueryMeta\n}\n\nexport interface DehydratedState {\n  mutations: Array<DehydratedMutation>\n  queries: Array<DehydratedQuery>\n}\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...(mutation.meta && { meta: mutation.meta }),\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...(query.meta && { meta: query.meta }),\n  }\n}\n\nexport function defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nexport function defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {},\n): DehydratedState {\n  const filterMutation =\n    options.shouldDehydrateMutation ?? defaultShouldDehydrateMutation\n\n  const mutations = client\n    .getMutationCache()\n    .getAll()\n    .flatMap((mutation) =>\n      filterMutation(mutation) ? [dehydrateMutation(mutation)] : [],\n    )\n\n  const filterQuery =\n    options.shouldDehydrateQuery ?? defaultShouldDehydrateQuery\n\n  const queries = client\n    .getQueryCache()\n    .getAll()\n    .flatMap((query) => (filterQuery(query) ? [dehydrateQuery(query)] : []))\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions,\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach((dehydratedMutation) => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n        meta: dehydratedMutation.meta,\n      },\n      dehydratedMutation.state,\n    )\n  })\n\n  queries.forEach(({ queryKey, state, queryHash, meta }) => {\n    const query = queryCache.get(queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < state.dataUpdatedAt) {\n        // omit fetchStatus from dehydrated state\n        // so that query stays in its current fetchStatus\n        const { fetchStatus: _ignored, ...dehydratedQueryState } = state\n        query.setState(dehydratedQueryState)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey,\n        queryHash,\n        meta,\n      },\n      // Reset fetch status to idle to avoid\n      // query being stuck in fetching state upon hydration\n      {\n        ...state,\n        fetchStatus: 'idle',\n      },\n    )\n  })\n}\n","'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefaultError,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'suspense'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    TError,\n                    TData,\n                    TQueryKey\n                  >\n                : T extends {\n                      queryFn?: QueryFunction<\n                        infer TQueryFnData,\n                        infer TQueryKey\n                      >\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseQueryOptionsForUseQueries<\n                      TQueryFnData,\n                      TError,\n                      TQueryFnData,\n                      TQueryKey\n                    >\n                  : // Fallback\n                    UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? UseQueryResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedUseQueryResult<TData, TError>\n            : UseQueryResult<TData, TError>\n        : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<infer TQueryFnData, any>\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? GetDefinedOrUndefinedQueryResult<\n                    T,\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : T extends {\n                      queryFn?: QueryFunction<infer TQueryFnData, any>\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? GetDefinedOrUndefinedQueryResult<\n                      T,\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : // Fallback\n                    UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetOptions<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? QueriesOptions<\n            [...Tail],\n            [...Result, GetOptions<Head>],\n            [...Depth, 1]\n          >\n        : Array<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetResults<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? QueriesResults<\n            [...Tail],\n            [...Result, GetResults<Head>],\n            [...Depth, 1]\n          >\n        : T extends Array<\n              UseQueryOptionsForUseQueries<\n                infer TQueryFnData,\n                infer TError,\n                infer TData,\n                any\n              >\n            >\n          ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n            Array<\n              UseQueryResult<\n                unknown extends TData ? TQueryFnData : TData,\n                unknown extends TError ? DefaultError : TError\n              >\n            >\n          : // Fallback\n            Array<UseQueryResult>\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries: readonly [...QueriesOptions<T>]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(opts)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(defaultedQueries)\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n      {\n        listeners: false,\n      },\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n      {\n        listeners: false,\n      },\n    )\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        throwOnError: defaultedQueries[index]?.throwOnError ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n","'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport { defaultThrowOnError } from './suspense'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\nimport type { DefaultError, QueryClient, QueryKey } from '@tanstack/query-core'\n\nexport function useSuspenseQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseSuspenseQueryResult<TData, TError> {\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n    },\n    QueryObserver,\n    queryClient,\n  ) as UseSuspenseQueryResult<TData, TError>\n}\n","'use client'\nimport { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport { defaultThrowOnError } from './suspense'\nimport type {\n  InfiniteQueryObserverSuccessResult,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type {\n  DefaultError,\n  InfiniteData,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  UseSuspenseInfiniteQueryOptions,\n  UseSuspenseInfiniteQueryResult,\n} from './types'\n\nexport function useSuspenseInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UseSuspenseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseSuspenseInfiniteQueryResult<TData, TError> {\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    InfiniteQueryObserver as typeof QueryObserver,\n    queryClient,\n  ) as InfiniteQueryObserverSuccessResult<TData, TError>\n}\n","'use client'\nimport { useQueries } from './useQueries'\nimport { defaultThrowOnError } from './suspense'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\nimport type {\n  DefaultError,\n  QueryClient,\n  QueryFunction,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetSuspenseOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseSuspenseQueryOptions<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseSuspenseQueryOptions<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseSuspenseQueryOptions<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseSuspenseQueryOptions<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseSuspenseQueryOptions<\n                    TQueryFnData,\n                    TError,\n                    TData,\n                    TQueryKey\n                  >\n                : T extends {\n                      queryFn?: QueryFunction<\n                        infer TQueryFnData,\n                        infer TQueryKey\n                      >\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseSuspenseQueryOptions<\n                      TQueryFnData,\n                      TError,\n                      TQueryFnData,\n                      TQueryKey\n                    >\n                  : // Fallback\n                    UseSuspenseQueryOptions\n\ntype GetSuspenseResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseSuspenseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseSuspenseQueryResult<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseSuspenseQueryResult<TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? UseSuspenseQueryResult<TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseSuspenseQueryResult<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseSuspenseQueryResult<TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<infer TQueryFnData, any>\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseSuspenseQueryResult<\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : T extends {\n                      queryFn?: QueryFunction<infer TQueryFnData, any>\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseSuspenseQueryResult<\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : // Fallback\n                    UseSuspenseQueryResult\n\n/**\n * SuspenseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type SuspenseQueriesOptions<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryOptions>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetSuspenseOptions<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? SuspenseQueriesOptions<\n            [...Tail],\n            [...Result, GetSuspenseOptions<Head>],\n            [...Depth, 1]\n          >\n        : Array<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseSuspenseQueryOptions<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n              >\n            : // Fallback\n              Array<UseSuspenseQueryOptions>\n\n/**\n * SuspenseQueriesResults reducer recursively maps type param to results\n */\nexport type SuspenseQueriesResults<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetSuspenseResults<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? SuspenseQueriesResults<\n            [...Tail],\n            [...Result, GetSuspenseResults<Head>],\n            [...Depth, 1]\n          >\n        : T extends Array<\n              UseSuspenseQueryOptions<\n                infer TQueryFnData,\n                infer TError,\n                infer TData,\n                any\n              >\n            >\n          ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n            Array<\n              UseSuspenseQueryResult<\n                unknown extends TData ? TQueryFnData : TData,\n                unknown extends TError ? DefaultError : TError\n              >\n            >\n          : // Fallback\n            Array<UseSuspenseQueryResult>\n\nexport function useSuspenseQueries<\n  T extends Array<any>,\n  TCombinedResult = SuspenseQueriesResults<T>,\n>(\n  options: {\n    queries: readonly [...SuspenseQueriesOptions<T>]\n    combine?: (result: SuspenseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  return useQueries(\n    {\n      ...options,\n      queries: options.queries.map((query) => ({\n        ...query,\n        suspense: true,\n        throwOnError: defaultThrowOnError,\n        enabled: true,\n      })),\n    } as any,\n    queryClient,\n  )\n}\n","import type { DataTag, DefaultError, QueryKey } from '@tanstack/query-core'\nimport type { UseQueryOptions } from './types'\n\nexport type UndefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData?: undefined\n}\n\ntype NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData:\n    | NonUndefinedGuard<TQueryFnData>\n    | (() => NonUndefinedGuard<TQueryFnData>)\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TData>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TData>\n}\n\nexport function queryOptions(options: unknown) {\n  return options\n}\n","import type { DataTag } from '@tanstack/query-core'\nimport type { InfiniteData } from '@tanstack/query-core'\nimport type { UseInfiniteQueryOptions } from './types'\nimport type { DefaultError, QueryKey } from '@tanstack/query-core'\n\nexport type UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData?: undefined\n}\n\ntype NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData:\n    | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n    | (() => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>)\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, TData>\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, TData>\n}\n\nexport function infiniteQueryOptions(options: unknown) {\n  return options\n}\n","'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state?: unknown\n  options?: Omit<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: Omit<HydrateOptions['defaultOptions'], 'mutations'>\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n  const [hydrationQueue, setHydrationQueue] = React.useState<\n    DehydratedState['queries'] | undefined\n  >()\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // This useMemo is for performance reasons only, everything inside it _must_\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  React.useMemo(() => {\n    if (state) {\n      if (typeof state !== 'object') {\n        return\n      }\n\n      const queryCache = client.getQueryCache()\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      const queries = (state as DehydratedState).queries || []\n\n      const newQueries: DehydratedState['queries'] = []\n      const existingQueries: DehydratedState['queries'] = []\n      for (const dehydratedQuery of queries) {\n        const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n        if (!existingQuery) {\n          newQueries.push(dehydratedQuery)\n        } else {\n          const hydrationIsNewer =\n            dehydratedQuery.state.dataUpdatedAt >\n            existingQuery.state.dataUpdatedAt\n          const queryAlreadyQueued = hydrationQueue?.find(\n            (query) => query.queryHash === dehydratedQuery.queryHash,\n          )\n\n          if (\n            hydrationIsNewer &&\n            (!queryAlreadyQueued ||\n              dehydratedQuery.state.dataUpdatedAt >\n                queryAlreadyQueued.state.dataUpdatedAt)\n          ) {\n            existingQueries.push(dehydratedQuery)\n          }\n        }\n      }\n\n      if (newQueries.length > 0) {\n        // It's actually fine to call this with queries/state that already exists\n        // in the cache, or is older. hydrate() is idempotent for queries.\n        hydrate(client, { queries: newQueries }, optionsRef.current)\n      }\n      if (existingQueries.length > 0) {\n        setHydrationQueue((prev) =>\n          prev ? [...prev, ...existingQueries] : existingQueries,\n        )\n      }\n    }\n  }, [client, hydrationQueue, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n      setHydrationQueue(undefined)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n","'use client'\nimport * as React from 'react'\nimport { notifyManager } from '@tanstack/query-core'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport type { QueryClient, QueryFilters } from '@tanstack/query-core'\n\nexport function useIsFetching(\n  filters?: QueryFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  const queryCache = client.getQueryCache()\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => client.isFetching(filters),\n    () => client.isFetching(filters),\n  )\n}\n","'use client'\nimport * as React from 'react'\n\nimport { notifyManager, replaceEqualDeep } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DefaultError,\n  Mutation,\n  MutationCache,\n  MutationFilters,\n  MutationState,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  return useMutationState(\n    { filters: { ...filters, status: 'pending' } },\n    client,\n  ).length\n}\n\ntype MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (\n    mutation: Mutation<unknown, DefaultError, unknown, unknown>,\n  ) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select\n          ? options.select(\n              mutation as Mutation<unknown, DefaultError, unknown, unknown>,\n            )\n          : mutation.state) as TResult,\n    )\n}\n\nexport function useMutationState<TResult = MutationState>(\n  options: MutationStateOptions<TResult> = {},\n  queryClient?: QueryClient,\n): Array<TResult> {\n  const mutationCache = useQueryClient(queryClient).getMutationCache()\n  const optionsRef = React.useRef(options)\n  const result = React.useRef<Array<TResult>>()\n  if (!result.current) {\n    result.current = getResult(mutationCache, options)\n  }\n\n  React.useEffect(() => {\n    optionsRef.current = options\n  })\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(() => {\n          const nextResult = replaceEqualDeep(\n            result.current,\n            getResult(mutationCache, optionsRef.current),\n          )\n          if (result.current !== nextResult) {\n            result.current = nextResult\n            notifyManager.schedule(onStoreChange)\n          }\n        }),\n      [mutationCache],\n    ),\n    () => result.current,\n    () => result.current,\n  )!\n}\n","'use client'\nimport * as React from 'react'\nimport { MutationObserver, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { shouldThrowError } from './utils'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport type { DefaultError, QueryClient } from '@tanstack/query-core'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","'use client'\nimport { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  InfiniteData,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseInfiniteQueryResult,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataInfiniteOptions,\n  UndefinedInitialDataInfiniteOptions,\n} from './infiniteQueryOptions'\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): DefinedUseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery(\n  options: UseInfiniteQueryOptions,\n  queryClient?: QueryClient,\n) {\n  return useBaseQuery(\n    options,\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    InfiniteQueryObserver as typeof QueryObserver,\n    queryClient,\n  )\n}\n","import * as TanstackReactQuery from '@tanstack/react-query'\nimport type { Query, QueryClient, QueryKey } from '@tanstack/react-query'\n\nimport type { Middleware } from './types'\n\nexport const ReactQuery = TanstackReactQuery\n\nexport const isV5 = !!ReactQuery.useSuspenseQuery\n\nexport const suspenseOptions = {\n  enabled: true,\n  suspense: true,\n  useErrorBoundary: (_error: unknown, query: Query) =>\n    typeof query.state.data === 'undefined',\n}\n\nexport const withMiddleware = (\n  hook: any,\n  defaultOptions: any,\n  type: 'queries' | 'mutations'\n) => {\n  return function useMiddleware(\n    options?: { client?: QueryClient; use?: Middleware[] },\n    queryClient?: QueryClient\n  ) {\n    const [uses, opts]: [Middleware[], any] = [\n      ReactQuery.useQueryClient(\n        // @ts-ignore Compatible with ReactQuery v4\n        isV5 ? queryClient : options\n      ).getDefaultOptions()[type],\n      defaultOptions,\n      options,\n    ].reduce(\n      ([u1, o1], { use: u2 = [], ...o2 } = {}) => [\n        [...u1, ...u2],\n        { ...o1, ...o2 },\n      ],\n      [[]]\n    )\n    const composedHook = uses.reduceRight((next, use) => use(next), hook)\n\n    return composedHook(opts, queryClient)\n  }\n}\n\nexport const getKey = (queryKey: QueryKey, variables?: any): QueryKey => {\n  return typeof variables === 'undefined' ? queryKey : [...queryKey, variables]\n}\n","import type {\n  QueryClient,\n  QueryFunctionContext,\n  UseBaseQueryOptions,\n  UseInfiniteQueryOptions,\n} from '@tanstack/react-query'\n\nimport type { AdditionalQueryOptions, Middleware } from './types'\nimport { getKey as getFullKey, withMiddleware } from './utils'\n\ninterface CreateBaseQueryOptions\n  extends Omit<UseInfiniteQueryOptions, 'queryFn'>,\n    AdditionalQueryOptions<any, any> {\n  use?: Middleware[]\n  variables?: any\n}\n\ntype QueryBaseHookOptions = Omit<\n  UseBaseQueryOptions,\n  'queryKey' | 'queryFn'\n> & {\n  fetcher?: any\n  variables?: any\n}\n\nexport const createBaseQuery = (\n  defaultOptions: any,\n  useRQHook: (options: any, queryClient?: any) => any,\n  overrideOptions?: Partial<UseInfiniteQueryOptions>\n): any => {\n  if (process.env.NODE_ENV !== 'production') {\n    // @ts-ignore\n    if (defaultOptions.useDefaultOptions) {\n      console.error(\n        '[Bug] useDefaultOptions is not supported, please use middleware instead.'\n      )\n    }\n\n    // @ts-ignore\n    if (defaultOptions.queryFn) {\n      console.error(\n        '[Bug] queryFn is not supported, please use fetcher instead.'\n      )\n    }\n  }\n\n  const {\n    queryKey,\n    fetcher,\n    queryKeyHashFn,\n    getPreviousPageParam,\n    getNextPageParam,\n    initialPageParam,\n  } = defaultOptions as CreateBaseQueryOptions\n\n  const getQueryOptions = (fetcherFn: any, variables: any) => {\n    return {\n      queryFn: (context: QueryFunctionContext) => fetcherFn(variables, context),\n      queryKey: getFullKey(queryKey, variables),\n    }\n  }\n\n  const getKey = (variables?: any) => getFullKey(queryKey, variables)\n\n  const getOptions = (variables: any) => {\n    return {\n      ...defaultOptions,\n      ...getQueryOptions(fetcher, variables),\n    }\n  }\n\n  const getFetchOptions = (variables: any) => {\n    return {\n      queryKeyHashFn,\n      getPreviousPageParam,\n      getNextPageParam,\n      initialPageParam,\n      ...getQueryOptions(fetcher, variables),\n    }\n  }\n\n  const useBaseHook = (\n    options: QueryBaseHookOptions,\n    queryClient?: QueryClient\n  ) => {\n    return useRQHook(\n      {\n        ...options,\n        ...overrideOptions,\n        ...getQueryOptions(options.fetcher, options.variables),\n      },\n      queryClient\n    )\n  }\n\n  return Object.assign(withMiddleware(useBaseHook, defaultOptions, 'queries'), {\n    fetcher,\n    getKey,\n    getOptions,\n    getFetchOptions,\n  })\n}\n","import { createBaseQuery } from './createBaseQuery'\nimport type { CompatibleError, CreateQueryOptions, QueryHook } from './types'\nimport { ReactQuery } from './utils'\n\nexport const createQuery = <\n  TFnData,\n  TVariables = void,\n  TError = CompatibleError\n>(\n  options: CreateQueryOptions<TFnData, TVariables, TError>\n): QueryHook<TFnData, TVariables, TError> => {\n  return createBaseQuery(options, ReactQuery.useQuery)\n}\n"],"names":["difference","array1","array2","filter","x","includes","QueriesObserver","_client","WeakMap","_result","_queries","_observers","_options","_combinedResult","_setResult","WeakSet","_combineResult","_findMatchingObservers","_onUpdate","_notify","Subscribable","constructor","client","queries","options","super","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","this","_classPrivateMethodGet","_setResult2","call","setQueries","onSubscribe","listeners","size","_classPrivateFieldGet","forEach","observer","subscribe","result","_onUpdate2","onUnsubscribe","destroy","Set","notifyOptions","notifyManager","batch","prevObservers","newObserverMatches","_findMatchingObservers2","match","setOptions","defaultedQueryOptions","newObservers","map","newResult","getCurrentResult","hasIndexChange","some","index","length","hasListeners","_notify2","getQueries","getCurrentQuery","getObservers","getOptimisticResult","matches","r","_combineResult2","observerResult","notifyOnChangeProps","trackResult","input","_classPrivateFieldGet2","combine","replaceEqualDeep","prevObserversMap","Map","queryHash","defaultQueryOptions","matchingObservers","flatMap","defaultedOptions","get","matchedQueryHashes","unmatchedQueries","has","getObserver","currentObserver","find","o","QueryObserver","newOrReusedObservers","concat","sort","sortMatchesByOrderOfQueries","a","b","indexOf","array","copy","slice","replaceAt","listener","InfiniteQueryObserver","bindMethods","fetchNextPage","bind","fetchPreviousPage","behavior","infiniteQueryBehavior","fetch","meta","fetchMore","direction","createResult","query","_state$fetchMeta","_state$fetchMeta2","state","isFetching","isRefetching","isFetchingNextPage","fetchMeta","isFetchingPreviousPage","hasNextPage","data","hasPreviousPage","MutationObserver","_currentResult","_currentMutation","_mutateOptions","_updateResult","_updateResult2","mutate","reset","prevOptions","defaultMutationOptions","shallowEqualObjects","getMutationCache","notify","type","mutation","mutationKey","hashKey","_classPrivateFieldGet3","removeObserver","onMutationUpdate","action","_classPrivateFieldGet4","variables","_classPrivateFieldGet5","build","addObserver","execute","_classPrivateFieldGet6","_classPrivateFieldGet7","getDefaultState","isPending","status","isSuccess","isError","isIdle","context","_classPrivateFieldGet8","_classPrivateFieldGet9","_classPrivateFieldGet10","_classPrivateFieldGet11","onSuccess","onSettled","_classPrivateFieldGet12","_classPrivateFieldGet13","_classPrivateFieldGet14","_classPrivateFieldGet15","onError","error","dehydrateMutation","dehydrateQuery","queryKey","defaultShouldDehydrateMutation","isPaused","defaultShouldDehydrateQuery","dehydrate","_options$shouldDehydr","_options$shouldDehydr2","arguments","undefined","filterMutation","shouldDehydrateMutation","mutations","getAll","filterQuery","shouldDehydrateQuery","getQueryCache","hydrate","dehydratedState","mutationCache","queryCache","dehydratedMutation","_options$defaultOptio","defaultOptions","_ref","_options$defaultOptio2","dataUpdatedAt","fetchStatus","_ignored","dehydratedQueryState","setState","useQueries","queryClient","useQueryClient","isRestoring","useIsRestoring","errorResetBoundary","useQueryErrorResetBoundary","defaultedQueries","React","opts","_optimisticResults","ensureStaleTime","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","optimisticResult","getCombinedResult","onStoreChange","batchCalls","suspensePromises","shouldSuspend","queryObserver","fetchOptimistic","willFetch","Promise","all","observerQueries","firstSingleResultWhichShouldThrow","_defaultedQueries$ind","_defaultedQueries$ind2","getHasError","throwOnError","useSuspenseQuery","useBaseQuery","enabled","suspense","defaultThrowOnError","useSuspenseInfiniteQuery","useSuspenseQueries","queryOptions","infiniteQueryOptions","HydrationBoundary","children","hydrationQueue","setHydrationQueue","optionsRef","current","newQueries","existingQueries","dehydratedQuery","existingQuery","hydrationIsNewer","queryAlreadyQueued","push","prev","useIsFetching","filters","useIsMutating","useMutationState","getResult","findAll","select","nextResult","schedule","useMutation","mutateOptions","catch","noop","shouldThrowError","mutateAsync","useInfiniteQuery","ReactQuery","TanstackReactQuery","isV5","getKey","createBaseQuery","useRQHook","overrideOptions","fetcher","queryKeyHashFn","getPreviousPageParam","getNextPageParam","initialPageParam","getQueryOptions","fetcherFn","queryFn","Object","assign","withMiddleware","hook","uses","getDefaultOptions","reduce","u1","o1","use","u2","o2","reduceRight","next","composedHook","useBaseHook","getOptions","getFetchOptions","createQuery","useQuery"],"sourceRoot":""}