{"version":3,"file":"static/js/619.27771062.chunk.js","mappings":"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","sources":["../node_modules/@mantine/core/src/components/ScrollArea/ScrollArea.context.ts","../node_modules/@mantine/hooks/src/use-callback-ref/use-callback-ref.ts","../node_modules/@mantine/core/src/components/ScrollArea/use-resize-observer.ts","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaCorner/ScrollAreaCorner.tsx","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaRoot/ScrollAreaRoot.tsx","../node_modules/@mantine/hooks/src/use-debounced-callback/use-debounced-callback.ts","../node_modules/@mantine/core/src/components/ScrollArea/utils/get-thumb-ratio.tsx","../node_modules/@mantine/core/src/components/ScrollArea/utils/get-thumb-size.tsx","../node_modules/@mantine/core/src/components/ScrollArea/utils/linear-scale.ts","../node_modules/@mantine/core/src/components/ScrollArea/utils/get-thumb-offset-from-scroll.ts","../node_modules/@mantine/core/src/components/ScrollArea/utils/is-scrolling-within-scrollbar-bounds.ts","../node_modules/@mantine/core/src/components/ScrollArea/utils/to-int.ts","../node_modules/@mantine/core/src/components/ScrollArea/utils/compose-event-handlers.ts","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.context.ts","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.tsx","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaScrollbar/ScrollbarX.tsx","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaScrollbar/ScrollbarY.tsx","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarVisible.tsx","../node_modules/@mantine/core/src/components/ScrollArea/utils/get-scroll-position-from-pointer.ts","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarAuto.tsx","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarHover.tsx","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarScroll.tsx","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbar.tsx","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaThumb/ScrollAreaThumb.tsx","../node_modules/@mantine/core/src/components/ScrollArea/utils/add-unlinked-scroll-listener.tsx","../node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaViewport/ScrollAreaViewport.tsx","../node_modules/@mantine/core/src/components/ScrollArea/ScrollArea.tsx","../node_modules/@mantine/core/src/core/DirectionProvider/DirectionProvider.tsx"],"sourcesContent":["import { createSafeContext } from '../../core';\n\nexport interface ScrollAreaContextValue {\n  type: 'auto' | 'always' | 'scroll' | 'hover' | 'never';\n  scrollHideDelay: number;\n  scrollArea: HTMLDivElement | null;\n  viewport: HTMLDivElement | null;\n  onViewportChange: (viewport: HTMLDivElement | null) => void;\n  content: HTMLDivElement | null;\n  onContentChange: (content: HTMLDivElement) => void;\n  scrollbarX: HTMLDivElement | null;\n  onScrollbarXChange: (scrollbar: HTMLDivElement | null) => void;\n  scrollbarXEnabled: boolean;\n  onScrollbarXEnabledChange: (rendered: boolean) => void;\n  scrollbarY: HTMLDivElement | null;\n  onScrollbarYChange: (scrollbar: HTMLDivElement | null) => void;\n  scrollbarYEnabled: boolean;\n  onScrollbarYEnabledChange: (rendered: boolean) => void;\n  onCornerWidthChange: (width: number) => void;\n  onCornerHeightChange: (height: number) => void;\n}\n\nexport const [ScrollAreaProvider, useScrollAreaContext] = createSafeContext<ScrollAreaContextValue>(\n  'ScrollArea.Root component was not found in tree'\n);\n","import { useEffect, useMemo, useRef } from 'react';\n\nexport function useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined): T {\n  const callbackRef = useRef(callback);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  return useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, []);\n}\n","import { useCallbackRef, useIsomorphicEffect } from '@mantine/hooks';\n\nexport function useResizeObserver(element: HTMLElement | null, onResize: () => void) {\n  const handleResize = useCallbackRef(onResize);\n\n  useIsomorphicEffect(() => {\n    let rAF = 0;\n    if (element) {\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n\n      resizeObserver.observe(element);\n\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n\n    return undefined;\n  }, [element, handleResize]);\n}\n","import React from 'react';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { useResizeObserver } from '../use-resize-observer';\n\ninterface ScrollAreaCornerProps extends React.ComponentPropsWithoutRef<'div'> {}\n\nexport const Corner = React.forwardRef<HTMLDivElement, ScrollAreaCornerProps>((props, ref) => {\n  const { style, ...others } = props;\n  const ctx = useScrollAreaContext();\n  const [width, setWidth] = React.useState(0);\n  const [height, setHeight] = React.useState(0);\n  const hasSize = Boolean(width && height);\n\n  useResizeObserver(ctx.scrollbarX, () => {\n    const h = ctx.scrollbarX?.offsetHeight || 0;\n    ctx.onCornerHeightChange(h);\n    setHeight(h);\n  });\n\n  useResizeObserver(ctx.scrollbarY, () => {\n    const w = ctx.scrollbarY?.offsetWidth || 0;\n    ctx.onCornerWidthChange(w);\n    setWidth(w);\n  });\n\n  return hasSize ? <div {...others} ref={ref} style={{ ...style, width, height }} /> : null;\n});\n\nexport const ScrollAreaCorner = React.forwardRef<HTMLDivElement, ScrollAreaCornerProps>(\n  (props, ref) => {\n    const ctx = useScrollAreaContext();\n    const hasBothScrollbarsVisible = Boolean(ctx.scrollbarX && ctx.scrollbarY);\n    const hasCorner = ctx.type !== 'scroll' && hasBothScrollbarsVisible;\n    return hasCorner ? <Corner {...props} ref={ref} /> : null;\n  }\n);\n","import React, { forwardRef, useState } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { Box, BoxProps, ElementProps, Factory, useProps } from '../../../core';\nimport { ScrollAreaProvider } from '../ScrollArea.context';\n\nexport type ScrollAreaRootStylesNames =\n  | 'root'\n  | 'viewport'\n  | 'viewportInner'\n  | 'scrollbar'\n  | 'thumb'\n  | 'corner';\n\nexport type ScrollAreaRootCssVariables = {\n  root: '--sa-corner-width' | '--sa-corner-height';\n};\n\nexport interface ScrollAreaRootStylesCtx {\n  cornerWidth: number;\n  cornerHeight: number;\n}\n\nexport interface ScrollAreaRootProps extends BoxProps, ElementProps<'div'> {\n  /**\n   * Defines scrollbars behavior, `hover` by default\n   * - `hover` – scrollbars are visible when mouse is over the scroll area\n   * - `scroll` – scrollbars are visible when the scroll area is scrolled\n   * - `always` – scrollbars are always visible\n   * - `never` – scrollbars are always hidden\n   * - `auto` – similar to `overflow: auto` – scrollbars are always visible when the content is overflowing\n   * */\n  type?: 'auto' | 'always' | 'scroll' | 'hover' | 'never';\n\n  /** Axis at which scrollbars must be rendered, `'xy'` by default */\n  scrollbars?: 'x' | 'y' | 'xy' | false;\n\n  /** Scroll hide delay in ms, applicable only when type is set to `hover` or `scroll`, `1000` by default */\n  scrollHideDelay?: number;\n}\n\nexport type ScrollAreaRootFactory = Factory<{\n  props: ScrollAreaRootProps;\n  ref: HTMLDivElement;\n  stylesNames: ScrollAreaRootStylesNames;\n}>;\n\nconst defaultProps: Partial<ScrollAreaRootProps> = {\n  scrollHideDelay: 1000,\n  type: 'hover',\n};\n\nexport const ScrollAreaRoot = forwardRef<HTMLDivElement, ScrollAreaRootProps>((_props, ref) => {\n  const props = useProps('ScrollAreaRoot', defaultProps, _props);\n  const { type, scrollHideDelay, scrollbars, ...others } = props;\n\n  const [scrollArea, setScrollArea] = useState<HTMLDivElement | null>(null);\n  const [viewport, setViewport] = useState<HTMLDivElement | null>(null);\n  const [content, setContent] = useState<HTMLDivElement | null>(null);\n  const [scrollbarX, setScrollbarX] = useState<HTMLDivElement | null>(null);\n  const [scrollbarY, setScrollbarY] = useState<HTMLDivElement | null>(null);\n  const [cornerWidth, setCornerWidth] = useState(0);\n  const [cornerHeight, setCornerHeight] = useState(0);\n  const [scrollbarXEnabled, setScrollbarXEnabled] = useState(false);\n  const [scrollbarYEnabled, setScrollbarYEnabled] = useState(false);\n  const rootRef = useMergedRef(ref, (node) => setScrollArea(node));\n\n  return (\n    <ScrollAreaProvider\n      value={{\n        type: type!,\n        scrollHideDelay: scrollHideDelay!,\n        scrollArea,\n        viewport,\n        onViewportChange: setViewport,\n        content,\n        onContentChange: setContent,\n        scrollbarX,\n        onScrollbarXChange: setScrollbarX,\n        scrollbarXEnabled,\n        onScrollbarXEnabledChange: setScrollbarXEnabled,\n        scrollbarY,\n        onScrollbarYChange: setScrollbarY,\n        scrollbarYEnabled,\n        onScrollbarYEnabledChange: setScrollbarYEnabled,\n        onCornerWidthChange: setCornerWidth,\n        onCornerHeightChange: setCornerHeight,\n      }}\n    >\n      <Box\n        {...others}\n        ref={rootRef}\n        __vars={{\n          '--sa-corner-width': scrollbars !== 'xy' ? '0px' : `${cornerWidth}px`,\n          '--sa-corner-height': scrollbars !== 'xy' ? '0px' : `${cornerHeight}px`,\n        }}\n      />\n    </ScrollAreaProvider>\n  );\n});\n\nScrollAreaRoot.displayName = '@mantine/core/ScrollAreaRoot';\n","import { useCallback, useEffect, useRef } from 'react';\nimport { useCallbackRef } from '../use-callback-ref/use-callback-ref';\n\nexport function useDebounceCallback(callback: () => void, delay: number) {\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = useRef(0);\n  useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);\n  return useCallback(() => {\n    window.clearTimeout(debounceTimerRef.current);\n    debounceTimerRef.current = window.setTimeout(handleCallback, delay);\n  }, [handleCallback, delay]);\n}\n","export function getThumbRatio(viewportSize: number, contentSize: number) {\n  const ratio = viewportSize / contentSize;\n  return Number.isNaN(ratio) ? 0 : ratio;\n}\n","import type { Sizes } from '../ScrollArea.types';\nimport { getThumbRatio } from './get-thumb-ratio';\n\nexport function getThumbSize(sizes: Sizes) {\n  const ratio = getThumbRatio(sizes.viewport, sizes.content);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;\n  return Math.max(thumbSize, 18);\n}\n","export function linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n","import type { Sizes } from '../ScrollArea.types';\nimport { getThumbSize } from './get-thumb-size';\nimport { linearScale } from './linear-scale';\n\nfunction clamp(value: number, [min, max]: [number, number]): number {\n  return Math.min(max, Math.max(min, value));\n}\n\nexport function getThumbOffsetFromScroll(\n  scrollPos: number,\n  sizes: Sizes,\n  dir: 'rtl' | 'ltr' = 'ltr'\n) {\n  const thumbSizePx = getThumbSize(sizes);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const scrollbar = sizes.scrollbar.size - scrollbarPadding;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const maxThumbPos = scrollbar - thumbSizePx;\n  const scrollClampRange = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange as [number, number]);\n  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);\n  return interpolate(scrollWithoutMomentum);\n}\n","export function isScrollingWithinScrollbarBounds(scrollPos: number, maxScrollPos: number) {\n  return scrollPos > 0 && scrollPos < maxScrollPos;\n}\n","export function toInt(value?: string) {\n  return value ? parseInt(value, 10) : 0;\n}\n","export function composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return (event: E) => {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !(event as unknown as Event).defaultPrevented) {\n      ourEventHandler?.(event);\n    }\n  };\n}\n","import { createSafeContext } from '../../../core';\n\nexport interface ScrollbarContextValue {\n  hasThumb: boolean;\n  scrollbar: HTMLDivElement | null;\n  onThumbChange: (thumb: HTMLDivElement | null) => void;\n  onThumbPointerUp: () => void;\n  onThumbPointerDown: (pointerPos: { x: number; y: number }) => void;\n  onThumbPositionChange: () => void;\n}\n\nexport const [ScrollbarProvider, useScrollbarContext] = createSafeContext<ScrollbarContextValue>(\n  'ScrollAreaScrollbar was not found in tree'\n);\n","import React, { forwardRef, useEffect } from 'react';\nimport { useCallbackRef, useDebounceCallback, useMergedRef } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { Sizes } from '../ScrollArea.types';\nimport { useResizeObserver } from '../use-resize-observer';\nimport { composeEventHandlers } from '../utils';\nimport { ScrollbarContextValue, ScrollbarProvider } from './Scrollbar.context';\n\nexport interface ScrollbarPrivateProps {\n  sizes: Sizes;\n  hasThumb: boolean;\n  onThumbChange: ScrollbarContextValue['onThumbChange'];\n  onThumbPointerUp: ScrollbarContextValue['onThumbPointerUp'];\n  onThumbPointerDown: ScrollbarContextValue['onThumbPointerDown'];\n  onThumbPositionChange: ScrollbarContextValue['onThumbPositionChange'];\n  onWheelScroll: (event: WheelEvent, maxScrollPos: number) => void;\n  onDragScroll: (pointerPos: { x: number; y: number }) => void;\n  onResize: () => void;\n}\n\ninterface ScrollbarProps\n  extends ScrollbarPrivateProps,\n    Omit<React.ComponentPropsWithoutRef<'div'>, 'onResize'> {}\n\nexport const Scrollbar = forwardRef<HTMLDivElement, ScrollbarProps>((props, forwardedRef) => {\n  const {\n    sizes,\n    hasThumb,\n    onThumbChange,\n    onThumbPointerUp,\n    onThumbPointerDown,\n    onThumbPositionChange,\n    onDragScroll,\n    onWheelScroll,\n    onResize,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext();\n  const [scrollbar, setScrollbar] = React.useState<HTMLDivElement | null>(null);\n  const composeRefs = useMergedRef(forwardedRef, (node) => setScrollbar(node));\n  const rectRef = React.useRef<ClientRect | null>(null);\n  const prevWebkitUserSelectRef = React.useRef<string>('');\n  const { viewport } = context;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const handleWheelScroll = useCallbackRef(onWheelScroll);\n  const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);\n  const handleResize = useDebounceCallback(onResize, 10);\n\n  const handleDragScroll = (event: React.PointerEvent<HTMLElement>) => {\n    if (rectRef.current) {\n      const x = event.clientX - rectRef.current.left;\n      const y = event.clientY - rectRef.current.top;\n      onDragScroll({ x, y });\n    }\n  };\n\n  useEffect(() => {\n    const handleWheel = (event: WheelEvent) => {\n      const element = event.target as HTMLElement;\n      const isScrollbarWheel = scrollbar?.contains(element);\n      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);\n    };\n    document.addEventListener('wheel', handleWheel, { passive: false });\n    return () => document.removeEventListener('wheel', handleWheel, { passive: false } as any);\n  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);\n\n  useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);\n\n  useResizeObserver(scrollbar, handleResize);\n  useResizeObserver(context.content, handleResize);\n\n  return (\n    <ScrollbarProvider\n      value={{\n        scrollbar,\n        hasThumb,\n        onThumbChange: useCallbackRef(onThumbChange),\n        onThumbPointerUp: useCallbackRef(onThumbPointerUp),\n        onThumbPositionChange: handleThumbPositionChange,\n        onThumbPointerDown: useCallbackRef(onThumbPointerDown),\n      }}\n    >\n      <div\n        {...scrollbarProps}\n        ref={composeRefs}\n        style={{ position: 'absolute', ...scrollbarProps.style }}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const mainPointer = 0;\n          if (event.button === mainPointer) {\n            const element = event.target as HTMLElement;\n            element.setPointerCapture(event.pointerId);\n            rectRef.current = scrollbar!.getBoundingClientRect();\n            prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;\n            document.body.style.webkitUserSelect = 'none';\n            handleDragScroll(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, handleDragScroll)}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const element = event.target as HTMLElement;\n          if (element.hasPointerCapture(event.pointerId)) {\n            element.releasePointerCapture(event.pointerId);\n          }\n          document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;\n          rectRef.current = null;\n        })}\n      />\n    </ScrollbarProvider>\n  );\n});\n","import React, { forwardRef, useEffect, useRef, useState } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { ScrollAreaScrollbarAxisProps } from '../ScrollArea.types';\nimport { getThumbSize, isScrollingWithinScrollbarBounds, toInt } from '../utils';\nimport { Scrollbar } from './Scrollbar';\n\nexport const ScrollAreaScrollbarX = forwardRef<HTMLDivElement, ScrollAreaScrollbarAxisProps>(\n  (props, forwardedRef) => {\n    const { sizes, onSizesChange, style, ...others } = props;\n    const ctx = useScrollAreaContext();\n    const [computedStyle, setComputedStyle] = useState<CSSStyleDeclaration>();\n    const ref = useRef<HTMLDivElement>(null);\n    const composeRefs = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);\n\n    useEffect(() => {\n      if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n    }, [ref]);\n\n    return (\n      <Scrollbar\n        data-orientation=\"horizontal\"\n        {...others}\n        ref={composeRefs}\n        sizes={sizes}\n        style={{\n          ...style,\n          ['--sa-thumb-width' as any]: `${getThumbSize(sizes)}px`,\n        }}\n        onThumbPointerDown={(pointerPos) => props.onThumbPointerDown(pointerPos.x)}\n        onDragScroll={(pointerPos) => props.onDragScroll(pointerPos.x)}\n        onWheelScroll={(event, maxScrollPos) => {\n          if (ctx.viewport) {\n            const scrollPos = ctx.viewport.scrollLeft + event.deltaX;\n            props.onWheelScroll(scrollPos);\n            if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n              event.preventDefault();\n            }\n          }\n        }}\n        onResize={() => {\n          if (ref.current && ctx.viewport && computedStyle) {\n            onSizesChange({\n              content: ctx.viewport.scrollWidth,\n              viewport: ctx.viewport.offsetWidth,\n              scrollbar: {\n                size: ref.current.clientWidth,\n                paddingStart: toInt(computedStyle.paddingLeft),\n                paddingEnd: toInt(computedStyle.paddingRight),\n              },\n            });\n          }\n        }}\n      />\n    );\n  }\n);\n","import React, { forwardRef, useEffect, useRef } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { ScrollAreaScrollbarAxisProps } from '../ScrollArea.types';\nimport { getThumbSize, isScrollingWithinScrollbarBounds, toInt } from '../utils';\nimport { Scrollbar } from './Scrollbar';\n\nexport const ScrollAreaScrollbarY = forwardRef<HTMLDivElement, ScrollAreaScrollbarAxisProps>(\n  (props, forwardedRef) => {\n    const { sizes, onSizesChange, style, ...others } = props;\n    const context = useScrollAreaContext();\n    const [computedStyle, setComputedStyle] = React.useState<CSSStyleDeclaration>();\n    const ref = useRef<HTMLDivElement>(null);\n    const composeRefs = useMergedRef(forwardedRef, ref, context.onScrollbarYChange);\n\n    useEffect(() => {\n      if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n    }, [ref]);\n\n    return (\n      <Scrollbar\n        {...others}\n        data-orientation=\"vertical\"\n        ref={composeRefs}\n        sizes={sizes}\n        style={{\n          ['--sa-thumb-height' as any]: `${getThumbSize(sizes)}px`,\n          ...style,\n        }}\n        onThumbPointerDown={(pointerPos) => props.onThumbPointerDown(pointerPos.y)}\n        onDragScroll={(pointerPos) => props.onDragScroll(pointerPos.y)}\n        onWheelScroll={(event, maxScrollPos) => {\n          if (context.viewport) {\n            const scrollPos = context.viewport.scrollTop + event.deltaY;\n            props.onWheelScroll(scrollPos);\n            if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n              event.preventDefault();\n            }\n          }\n        }}\n        onResize={() => {\n          if (ref.current && context.viewport && computedStyle) {\n            onSizesChange({\n              content: context.viewport.scrollHeight,\n              viewport: context.viewport.offsetHeight,\n              scrollbar: {\n                size: ref.current.clientHeight,\n                paddingStart: toInt(computedStyle.paddingTop),\n                paddingEnd: toInt(computedStyle.paddingBottom),\n              },\n            });\n          }\n        }}\n      />\n    );\n  }\n);\n","import React, { forwardRef, useRef, useState } from 'react';\nimport { useDirection } from '../../../core';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport {\n  ScrollAreaScrollbarAxisPrivateProps,\n  ScrollAreaScrollbarAxisProps,\n  Sizes,\n} from '../ScrollArea.types';\nimport { getScrollPositionFromPointer, getThumbOffsetFromScroll, getThumbRatio } from '../utils';\nimport { ScrollAreaScrollbarX } from './ScrollbarX';\nimport { ScrollAreaScrollbarY } from './ScrollbarY';\n\nexport interface ScrollAreaScrollbarVisibleProps\n  extends Omit<ScrollAreaScrollbarAxisProps, keyof ScrollAreaScrollbarAxisPrivateProps> {\n  orientation?: 'horizontal' | 'vertical';\n}\n\nexport const ScrollAreaScrollbarVisible = forwardRef<\n  HTMLDivElement,\n  ScrollAreaScrollbarVisibleProps\n>((props, forwardedRef) => {\n  const { orientation = 'vertical', ...scrollbarProps } = props;\n  const { dir } = useDirection();\n  const context = useScrollAreaContext();\n  const thumbRef = useRef<HTMLDivElement | null>(null);\n  const pointerOffsetRef = useRef(0);\n  const [sizes, setSizes] = useState<Sizes>({\n    content: 0,\n    viewport: 0,\n    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 },\n  });\n  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);\n\n  const commonProps: Omit<\n    ScrollAreaScrollbarAxisPrivateProps,\n    'onThumbPositionChange' | 'onDragScroll' | 'onWheelScroll'\n  > = {\n    ...scrollbarProps,\n    sizes,\n    onSizesChange: setSizes,\n    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),\n    onThumbChange: (thumb) => {\n      thumbRef.current = thumb;\n    },\n    onThumbPointerUp: () => {\n      pointerOffsetRef.current = 0;\n    },\n    onThumbPointerDown: (pointerPos) => {\n      pointerOffsetRef.current = pointerPos;\n    },\n  };\n\n  const getScrollPosition = (pointerPos: number, direction?: 'ltr' | 'rtl') =>\n    getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, direction);\n\n  if (orientation === 'horizontal') {\n    return (\n      <ScrollAreaScrollbarX\n        {...commonProps}\n        ref={forwardedRef}\n        onThumbPositionChange={() => {\n          if (context.viewport && thumbRef.current) {\n            const scrollPos = context.viewport.scrollLeft;\n            const offset = getThumbOffsetFromScroll(scrollPos, sizes, dir);\n            thumbRef.current.style.transform = `translate3d(${offset}px, 0, 0)`;\n          }\n        }}\n        onWheelScroll={(scrollPos) => {\n          if (context.viewport) context.viewport.scrollLeft = scrollPos;\n        }}\n        onDragScroll={(pointerPos) => {\n          if (context.viewport) {\n            context.viewport.scrollLeft = getScrollPosition(pointerPos, dir);\n          }\n        }}\n      />\n    );\n  }\n\n  if (orientation === 'vertical') {\n    return (\n      <ScrollAreaScrollbarY\n        {...commonProps}\n        ref={forwardedRef}\n        onThumbPositionChange={() => {\n          if (context.viewport && thumbRef.current) {\n            const scrollPos = context.viewport.scrollTop;\n            const offset = getThumbOffsetFromScroll(scrollPos, sizes);\n            thumbRef.current.style.transform = `translate3d(0, ${offset}px, 0)`;\n          }\n        }}\n        onWheelScroll={(scrollPos) => {\n          if (context.viewport) context.viewport.scrollTop = scrollPos;\n        }}\n        onDragScroll={(pointerPos) => {\n          if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);\n        }}\n      />\n    );\n  }\n\n  return null;\n});\n","import type { Sizes } from '../ScrollArea.types';\nimport { getThumbSize } from './get-thumb-size';\nimport { linearScale } from './linear-scale';\n\nexport function getScrollPositionFromPointer(\n  pointerPos: number,\n  pointerOffset: number,\n  sizes: Sizes,\n  dir: 'ltr' | 'rtl' = 'ltr'\n) {\n  const thumbSizePx = getThumbSize(sizes);\n  const thumbCenter = thumbSizePx / 2;\n  const offset = pointerOffset || thumbCenter;\n  const thumbOffsetFromEnd = thumbSizePx - offset;\n  const minPointerPos = sizes.scrollbar.paddingStart + offset;\n  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const scrollRange = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange as [number, number]);\n  return interpolate(pointerPos);\n}\n","import React, { forwardRef, useState } from 'react';\nimport { useDebounceCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { useResizeObserver } from '../use-resize-observer';\nimport {\n  ScrollAreaScrollbarVisible,\n  ScrollAreaScrollbarVisibleProps,\n} from './ScrollAreaScrollbarVisible';\n\nexport interface ScrollAreaScrollbarAutoProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbarAuto = forwardRef<HTMLDivElement, ScrollAreaScrollbarAutoProps>(\n  (props, ref) => {\n    const context = useScrollAreaContext();\n    const { forceMount, ...scrollbarProps } = props;\n    const [visible, setVisible] = useState(false);\n    const isHorizontal = props.orientation === 'horizontal';\n    const handleResize = useDebounceCallback(() => {\n      if (context.viewport) {\n        const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;\n        const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;\n        setVisible(isHorizontal ? isOverflowX : isOverflowY);\n      }\n    }, 10);\n\n    useResizeObserver(context.viewport, handleResize);\n    useResizeObserver(context.content, handleResize);\n\n    if (forceMount || visible) {\n      return (\n        <ScrollAreaScrollbarVisible\n          data-state={visible ? 'visible' : 'hidden'}\n          {...scrollbarProps}\n          ref={ref}\n        />\n      );\n    }\n\n    return null;\n  }\n);\n","import React, { forwardRef, useEffect, useState } from 'react';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { ScrollAreaScrollbarAuto, ScrollAreaScrollbarAutoProps } from './ScrollAreaScrollbarAuto';\n\ninterface ScrollAreaScrollbarHoverProps extends ScrollAreaScrollbarAutoProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbarHover = forwardRef<HTMLDivElement, ScrollAreaScrollbarHoverProps>(\n  (props, ref) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const [visible, setVisible] = useState(false);\n\n    useEffect(() => {\n      const { scrollArea } = context;\n      let hideTimer = 0;\n      if (scrollArea) {\n        const handlePointerEnter = () => {\n          window.clearTimeout(hideTimer);\n          setVisible(true);\n        };\n        const handlePointerLeave = () => {\n          hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);\n        };\n        scrollArea.addEventListener('pointerenter', handlePointerEnter);\n        scrollArea.addEventListener('pointerleave', handlePointerLeave);\n        return () => {\n          window.clearTimeout(hideTimer);\n          scrollArea.removeEventListener('pointerenter', handlePointerEnter);\n          scrollArea.removeEventListener('pointerleave', handlePointerLeave);\n        };\n      }\n\n      return undefined;\n    }, [context.scrollArea, context.scrollHideDelay]);\n\n    if (forceMount || visible) {\n      return (\n        <ScrollAreaScrollbarAuto\n          data-state={visible ? 'visible' : 'hidden'}\n          {...scrollbarProps}\n          ref={ref}\n        />\n      );\n    }\n\n    return null;\n  }\n);\n","import React, { forwardRef, useEffect, useState } from 'react';\nimport { useDebounceCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { composeEventHandlers } from '../utils';\nimport {\n  ScrollAreaScrollbarVisible,\n  ScrollAreaScrollbarVisibleProps,\n} from './ScrollAreaScrollbarVisible';\n\ninterface ScrollAreaScrollbarScrollProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbarScroll = forwardRef<HTMLDivElement, ScrollAreaScrollbarScrollProps>(\n  (props, red) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const isHorizontal = props.orientation === 'horizontal';\n    const [state, setState] = useState<'hidden' | 'idle' | 'interacting' | 'scrolling'>('hidden');\n    const debounceScrollEnd = useDebounceCallback(() => setState('idle'), 100);\n\n    useEffect(() => {\n      if (state === 'idle') {\n        const hideTimer = window.setTimeout(() => setState('hidden'), context.scrollHideDelay);\n        return () => window.clearTimeout(hideTimer);\n      }\n\n      return undefined;\n    }, [state, context.scrollHideDelay]);\n\n    useEffect(() => {\n      const { viewport } = context;\n      const scrollDirection = isHorizontal ? 'scrollLeft' : 'scrollTop';\n\n      if (viewport) {\n        let prevScrollPos = viewport[scrollDirection];\n        const handleScroll = () => {\n          const scrollPos = viewport[scrollDirection];\n          const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n          if (hasScrollInDirectionChanged) {\n            setState('scrolling');\n            debounceScrollEnd();\n          }\n          prevScrollPos = scrollPos;\n        };\n        viewport.addEventListener('scroll', handleScroll);\n        return () => viewport.removeEventListener('scroll', handleScroll);\n      }\n\n      return undefined;\n    }, [context.viewport, isHorizontal, debounceScrollEnd]);\n\n    if (forceMount || state !== 'hidden') {\n      return (\n        <ScrollAreaScrollbarVisible\n          data-state={state === 'hidden' ? 'hidden' : 'visible'}\n          {...scrollbarProps}\n          ref={red}\n          onPointerEnter={composeEventHandlers(props.onPointerEnter, () => setState('interacting'))}\n          onPointerLeave={composeEventHandlers(props.onPointerLeave, () => setState('idle'))}\n        />\n      );\n    }\n\n    return null;\n  }\n);\n","import React from 'react';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { ScrollAreaScrollbarAuto } from './ScrollAreaScrollbarAuto';\nimport { ScrollAreaScrollbarHover } from './ScrollAreaScrollbarHover';\nimport { ScrollAreaScrollbarScroll } from './ScrollAreaScrollbarScroll';\nimport {\n  ScrollAreaScrollbarVisible,\n  ScrollAreaScrollbarVisibleProps,\n} from './ScrollAreaScrollbarVisible';\n\ninterface ScrollAreaScrollbarProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbar = React.forwardRef<HTMLDivElement, ScrollAreaScrollbarProps>(\n  (props, forwardedRef) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;\n    const isHorizontal = props.orientation === 'horizontal';\n\n    React.useEffect(() => {\n      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);\n      return () => {\n        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);\n      };\n    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);\n\n    return context.type === 'hover' ? (\n      <ScrollAreaScrollbarHover {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'scroll' ? (\n      <ScrollAreaScrollbarScroll {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'auto' ? (\n      <ScrollAreaScrollbarAuto {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'always' ? (\n      <ScrollAreaScrollbarVisible {...scrollbarProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n","import React, { forwardRef, useEffect, useRef } from 'react';\nimport { useDebounceCallback, useMergedRef } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { useScrollbarContext } from '../ScrollAreaScrollbar/Scrollbar.context';\nimport { addUnlinkedScrollListener, composeEventHandlers } from '../utils';\n\ninterface ThumbProps extends React.ComponentPropsWithoutRef<'div'> {}\n\nexport const Thumb = forwardRef<HTMLDivElement, ThumbProps>((props, forwardedRef) => {\n  const { style, ...others } = props;\n  const scrollAreaContext = useScrollAreaContext();\n  const scrollbarContext = useScrollbarContext();\n  const { onThumbPositionChange } = scrollbarContext;\n  const composedRef = useMergedRef(forwardedRef, (node) => scrollbarContext.onThumbChange(node));\n  const removeUnlinkedScrollListenerRef = useRef<() => void>();\n  const debounceScrollEnd = useDebounceCallback(() => {\n    if (removeUnlinkedScrollListenerRef.current) {\n      removeUnlinkedScrollListenerRef.current();\n      removeUnlinkedScrollListenerRef.current = undefined;\n    }\n  }, 100);\n\n  useEffect(() => {\n    const { viewport } = scrollAreaContext;\n    if (viewport) {\n      const handleScroll = () => {\n        debounceScrollEnd();\n        if (!removeUnlinkedScrollListenerRef.current) {\n          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);\n          removeUnlinkedScrollListenerRef.current = listener;\n          onThumbPositionChange();\n        }\n      };\n      onThumbPositionChange();\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n\n    return undefined;\n  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);\n\n  return (\n    <div\n      data-state={scrollbarContext.hasThumb ? 'visible' : 'hidden'}\n      {...others}\n      ref={composedRef}\n      style={{\n        width: 'var(--sa-thumb-width)',\n        height: 'var(--sa-thumb-height)',\n        ...style,\n      }}\n      onPointerDownCapture={composeEventHandlers(props.onPointerDownCapture, (event) => {\n        const thumb = event.target as HTMLElement;\n        const thumbRect = thumb.getBoundingClientRect();\n        const x = event.clientX - thumbRect.left;\n        const y = event.clientY - thumbRect.top;\n        scrollbarContext.onThumbPointerDown({ x, y });\n      })}\n      onPointerUp={composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)}\n    />\n  );\n});\n\ninterface ScrollAreaThumbProps extends ThumbProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaThumb = React.forwardRef<HTMLDivElement, ScrollAreaThumbProps>(\n  (props, forwardedRef) => {\n    const { forceMount, ...thumbProps } = props;\n    const scrollbarContext = useScrollbarContext();\n\n    if (forceMount || scrollbarContext.hasThumb) {\n      return <Thumb ref={forwardedRef} {...thumbProps} />;\n    }\n\n    return null;\n  }\n);\n","export function addUnlinkedScrollListener(node: HTMLElement, handler = () => {}) {\n  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };\n  let rAF = 0;\n  (function loop() {\n    const position = { left: node.scrollLeft, top: node.scrollTop };\n    const isHorizontalScroll = prevPosition.left !== position.left;\n    const isVerticalScroll = prevPosition.top !== position.top;\n    if (isHorizontalScroll || isVerticalScroll) handler();\n    prevPosition = position;\n    rAF = window.requestAnimationFrame(loop);\n  })();\n  return () => window.cancelAnimationFrame(rAF);\n}\n","import React, { forwardRef } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { Box, BoxProps, ElementProps } from '../../../core';\nimport { useScrollAreaContext } from '../ScrollArea.context';\n\nexport interface ScrollAreaViewportProps extends BoxProps, ElementProps<'div'> {}\n\nexport const ScrollAreaViewport = forwardRef<HTMLDivElement, ScrollAreaViewportProps>(\n  ({ children, style, ...others }, ref) => {\n    const ctx = useScrollAreaContext();\n    const rootRef = useMergedRef(ref, ctx.onViewportChange);\n\n    return (\n      <Box\n        {...others}\n        ref={rootRef}\n        style={{\n          overflowX: ctx.scrollbarXEnabled ? 'scroll' : 'hidden',\n          overflowY: ctx.scrollbarYEnabled ? 'scroll' : 'hidden',\n          ...style,\n        }}\n      >\n        <div style={{ minWidth: '100%', display: 'table' }} ref={ctx.onContentChange}>\n          {children}\n        </div>\n      </Box>\n    );\n  }\n);\n\nScrollAreaViewport.displayName = '@mantine/core/ScrollAreaViewport';\n","import React, { useState } from 'react';\nimport {\n  Box,\n  BoxProps,\n  createVarsResolver,\n  ElementProps,\n  factory,\n  Factory,\n  rem,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../core';\nimport { ScrollAreaCorner } from './ScrollAreaCorner/ScrollAreaCorner';\nimport { ScrollAreaRoot } from './ScrollAreaRoot/ScrollAreaRoot';\nimport { ScrollAreaScrollbar } from './ScrollAreaScrollbar/ScrollAreaScrollbar';\nimport { ScrollAreaThumb } from './ScrollAreaThumb/ScrollAreaThumb';\nimport { ScrollAreaViewport } from './ScrollAreaViewport/ScrollAreaViewport';\nimport classes from './ScrollArea.module.css';\n\nexport type ScrollAreaStylesNames = 'root' | 'viewport' | 'scrollbar' | 'thumb' | 'corner';\nexport type ScrollAreaCssVariables = {\n  root: '--scrollarea-scrollbar-size';\n};\n\nexport interface ScrollAreaProps\n  extends BoxProps,\n    StylesApiProps<ScrollAreaFactory>,\n    ElementProps<'div'> {\n  /** Scrollbar size, any valid CSS value for width/height, numbers are converted to rem, default value is 0.75rem */\n  scrollbarSize?: number | string;\n\n  /**\n   * Defines scrollbars behavior, `hover` by default\n   * - `hover` – scrollbars are visible when mouse is over the scroll area\n   * - `scroll` – scrollbars are visible when the scroll area is scrolled\n   * - `always` – scrollbars are always visible\n   * - `never` – scrollbars are always hidden\n   * - `auto` – similar to `overflow: auto` – scrollbars are always visible when the content is overflowing\n   * */\n  type?: 'auto' | 'always' | 'scroll' | 'hover' | 'never';\n\n  /** Scroll hide delay in ms, applicable only when type is set to `hover` or `scroll`, `1000` by default */\n  scrollHideDelay?: number;\n\n  /** Axis at which scrollbars must be rendered, `'xy'` by default */\n  scrollbars?: 'x' | 'y' | 'xy' | false;\n\n  /** Determines whether scrollbars should be offset with padding on given axis, `false` by default */\n  offsetScrollbars?: boolean | 'x' | 'y';\n\n  /** Assigns viewport element (scrollable container) ref */\n  viewportRef?: React.ForwardedRef<HTMLDivElement>;\n\n  /** Props passed down to the viewport element */\n  viewportProps?: React.ComponentPropsWithRef<'div'>;\n\n  /** Called with current position (`x` and `y` coordinates) when viewport is scrolled */\n  onScrollPositionChange?: (position: { x: number; y: number }) => void;\n}\n\nexport interface ScrollAreaAutosizeProps extends ScrollAreaProps {}\n\nexport type ScrollAreaFactory = Factory<{\n  props: ScrollAreaProps;\n  ref: HTMLDivElement;\n  stylesNames: ScrollAreaStylesNames;\n  vars: ScrollAreaCssVariables;\n  staticComponents: {\n    Autosize: typeof ScrollAreaAutosize;\n  };\n}>;\n\nconst defaultProps: Partial<ScrollAreaProps> = {\n  scrollHideDelay: 1000,\n  type: 'hover',\n  scrollbars: 'xy',\n};\n\nconst varsResolver = createVarsResolver<ScrollAreaFactory>((_, { scrollbarSize }) => ({\n  root: {\n    '--scrollarea-scrollbar-size': rem(scrollbarSize),\n  },\n}));\n\nexport const ScrollArea = factory<ScrollAreaFactory>((_props, ref) => {\n  const props = useProps('ScrollArea', defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    scrollbarSize,\n    vars,\n    type,\n    scrollHideDelay,\n    viewportProps,\n    viewportRef,\n    onScrollPositionChange,\n    children,\n    offsetScrollbars,\n    scrollbars,\n    ...others\n  } = props;\n\n  const [scrollbarHovered, setScrollbarHovered] = useState(false);\n\n  const getStyles = useStyles<ScrollAreaFactory>({\n    name: 'ScrollArea',\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n  });\n\n  return (\n    <ScrollAreaRoot\n      type={type === 'never' ? 'always' : type}\n      scrollHideDelay={scrollHideDelay}\n      ref={ref}\n      scrollbars={scrollbars}\n      {...getStyles('root')}\n      {...others}\n    >\n      <ScrollAreaViewport\n        {...viewportProps}\n        {...getStyles('viewport')}\n        ref={viewportRef}\n        data-offset-scrollbars={offsetScrollbars === true ? 'xy' : offsetScrollbars || undefined}\n        data-scrollbars={scrollbars || undefined}\n        onScroll={\n          typeof onScrollPositionChange === 'function'\n            ? ({ currentTarget }) =>\n                onScrollPositionChange({\n                  x: currentTarget.scrollLeft,\n                  y: currentTarget.scrollTop,\n                })\n            : undefined\n        }\n      >\n        {children}\n      </ScrollAreaViewport>\n\n      {(scrollbars === 'xy' || scrollbars === 'x') && (\n        <ScrollAreaScrollbar\n          {...getStyles('scrollbar')}\n          orientation=\"horizontal\"\n          data-hidden={type === 'never' || undefined}\n          forceMount\n          onMouseEnter={() => setScrollbarHovered(true)}\n          onMouseLeave={() => setScrollbarHovered(false)}\n        >\n          <ScrollAreaThumb {...getStyles('thumb')} />\n        </ScrollAreaScrollbar>\n      )}\n\n      {(scrollbars === 'xy' || scrollbars === 'y') && (\n        <ScrollAreaScrollbar\n          {...getStyles('scrollbar')}\n          orientation=\"vertical\"\n          data-hidden={type === 'never' || undefined}\n          forceMount\n          onMouseEnter={() => setScrollbarHovered(true)}\n          onMouseLeave={() => setScrollbarHovered(false)}\n        >\n          <ScrollAreaThumb {...getStyles('thumb')} />\n        </ScrollAreaScrollbar>\n      )}\n\n      <ScrollAreaCorner\n        {...getStyles('corner')}\n        data-hovered={scrollbarHovered || undefined}\n        data-hidden={type === 'never' || undefined}\n      />\n    </ScrollAreaRoot>\n  );\n});\n\nScrollArea.displayName = '@mantine/core/ScrollArea';\n\nexport const ScrollAreaAutosize = factory<ScrollAreaFactory>((props, ref) => {\n  const {\n    children,\n    classNames,\n    styles,\n    scrollbarSize,\n    scrollHideDelay,\n    type,\n    dir,\n    offsetScrollbars,\n    viewportRef,\n    onScrollPositionChange,\n    unstyled,\n    variant,\n    viewportProps,\n    scrollbars,\n    style,\n    vars,\n    ...others\n  } = useProps('ScrollAreaAutosize', defaultProps, props);\n\n  return (\n    <Box {...others} ref={ref} style={[{ display: 'flex' }, style]}>\n      <Box style={{ display: 'flex', flexDirection: 'column', flex: 1 }}>\n        <ScrollArea\n          classNames={classNames}\n          styles={styles}\n          scrollHideDelay={scrollHideDelay}\n          scrollbarSize={scrollbarSize}\n          type={type}\n          dir={dir}\n          offsetScrollbars={offsetScrollbars}\n          viewportRef={viewportRef}\n          onScrollPositionChange={onScrollPositionChange}\n          unstyled={unstyled}\n          variant={variant}\n          viewportProps={viewportProps}\n          vars={vars}\n          scrollbars={scrollbars}\n        >\n          {children}\n        </ScrollArea>\n      </Box>\n    </Box>\n  );\n});\n\nScrollArea.classes = classes;\nScrollAreaAutosize.displayName = '@mantine/core/ScrollAreaAutosize';\nScrollAreaAutosize.classes = classes;\nScrollArea.Autosize = ScrollAreaAutosize;\n","import React, { createContext, useContext, useState } from 'react';\nimport { useIsomorphicEffect } from '@mantine/hooks';\n\nexport type Direction = 'ltr' | 'rtl';\n\nexport interface DirectionContextValue {\n  dir: Direction;\n  toggleDirection: () => void;\n  setDirection: (dir: Direction) => void;\n}\n\nexport const DirectionContext = createContext<DirectionContextValue>({\n  dir: 'ltr',\n  toggleDirection: () => {},\n  setDirection: () => {},\n});\n\nexport function useDirection() {\n  return useContext(DirectionContext);\n}\n\nexport interface DirectionProviderProps {\n  /** Your application */\n  children: React.ReactNode;\n\n  /** Direction set as a default value, `ltr` by default */\n  initialDirection?: Direction;\n\n  /** Determines whether direction should be updated on mount based on `dir` attribute set on root element (usually html element), `true` by default  */\n  detectDirection?: boolean;\n}\n\nexport function DirectionProvider({\n  children,\n  initialDirection = 'ltr',\n  detectDirection = true,\n}: DirectionProviderProps) {\n  const [dir, setDir] = useState<Direction>(initialDirection);\n\n  const setDirection = (direction: Direction) => {\n    setDir(direction);\n    document.documentElement.setAttribute('dir', direction);\n  };\n\n  const toggleDirection = () => setDirection(dir === 'ltr' ? 'rtl' : 'ltr');\n\n  useIsomorphicEffect(() => {\n    if (detectDirection) {\n      const direction = document.documentElement.getAttribute('dir');\n      if (direction === 'rtl' || direction === 'ltr') {\n        setDirection(direction);\n      }\n    }\n  }, []);\n\n  return (\n    <DirectionContext.Provider value={{ dir, toggleDirection, setDirection }}>\n      {children}\n    </DirectionContext.Provider>\n  );\n}\n"],"names":["ScrollAreaProvider","useScrollAreaContext","createSafeContext","useCallbackRef","callback","callbackRef","useRef","useEffect","current","useMemo","_callbackRef$current","_len","arguments","length","args","Array","_key","call","useResizeObserver","element","onResize","handleResize","useIsomorphicEffect","rAF","resizeObserver","ResizeObserver","cancelAnimationFrame","window","requestAnimationFrame","observe","unobserve","Corner","React","props","ref","style","others","ctx","width","setWidth","height","setHeight","hasSize","Boolean","scrollbarX","_ctx$scrollbarX","h","offsetHeight","onCornerHeightChange","scrollbarY","_ctx$scrollbarY","w","offsetWidth","onCornerWidthChange","ScrollAreaCorner","hasBothScrollbarsVisible","type","defaultProps","scrollHideDelay","ScrollAreaRoot","forwardRef","_props","useProps","scrollbars","scrollArea","setScrollArea","useState","viewport","setViewport","content","setContent","setScrollbarX","setScrollbarY","cornerWidth","setCornerWidth","cornerHeight","setCornerHeight","scrollbarXEnabled","setScrollbarXEnabled","scrollbarYEnabled","setScrollbarYEnabled","rootRef","useMergedRef","node","value","onViewportChange","onContentChange","onScrollbarXChange","onScrollbarXEnabledChange","onScrollbarYChange","onScrollbarYEnabledChange","Box","__vars","useDebounceCallback","delay","handleCallback","debounceTimerRef","clearTimeout","useCallback","setTimeout","displayName","getThumbRatio","viewportSize","contentSize","ratio","Number","isNaN","getThumbSize","sizes","scrollbarPadding","scrollbar","paddingStart","paddingEnd","thumbSize","size","Math","max","linearScale","input","output","getThumbOffsetFromScroll","scrollPos","dir","undefined","thumbSizePx","maxScrollPos","maxThumbPos","scrollWithoutMomentum","_ref","min","clamp","interpolate","isScrollingWithinScrollbarBounds","toInt","parseInt","composeEventHandlers","originalEventHandler","ourEventHandler","checkForDefaultPrevented","event","defaultPrevented","ScrollbarProvider","useScrollbarContext","Scrollbar","forwardedRef","hasThumb","onThumbChange","onThumbPointerUp","onThumbPointerDown","onThumbPositionChange","onDragScroll","onWheelScroll","scrollbarProps","context","setScrollbar","composeRefs","rectRef","prevWebkitUserSelectRef","handleWheelScroll","handleThumbPositionChange","handleDragScroll","x","clientX","left","y","clientY","top","handleWheel","target","contains","document","addEventListener","passive","removeEventListener","position","onPointerDown","button","setPointerCapture","pointerId","getBoundingClientRect","body","webkitUserSelect","onPointerMove","onPointerUp","hasPointerCapture","releasePointerCapture","ScrollAreaScrollbarX","onSizesChange","computedStyle","setComputedStyle","getComputedStyle","pointerPos","scrollLeft","deltaX","preventDefault","scrollWidth","clientWidth","paddingLeft","paddingRight","ScrollAreaScrollbarY","scrollTop","deltaY","scrollHeight","clientHeight","paddingTop","paddingBottom","ScrollAreaScrollbarVisible","orientation","useDirection","thumbRef","pointerOffsetRef","setSizes","thumbRatio","commonProps","thumb","getScrollPosition","direction","pointerOffset","offset","thumbOffsetFromEnd","minPointerPos","maxPointerPos","getScrollPositionFromPointer","transform","ScrollAreaScrollbarAuto","forceMount","visible","setVisible","isHorizontal","isOverflowX","isOverflowY","ScrollAreaScrollbarHover","hideTimer","handlePointerEnter","handlePointerLeave","ScrollAreaScrollbarScroll","red","state","setState","debounceScrollEnd","scrollDirection","prevScrollPos","handleScroll","onPointerEnter","onPointerLeave","ScrollAreaScrollbar","Thumb","scrollAreaContext","scrollbarContext","composedRef","removeUnlinkedScrollListenerRef","listener","handler","prevPosition","loop","isHorizontalScroll","isVerticalScroll","addUnlinkedScrollListener","onPointerDownCapture","thumbRect","ScrollAreaThumb","thumbProps","ScrollAreaViewport","children","overflowX","overflowY","minWidth","display","varsResolver","createVarsResolver","_","scrollbarSize","root","rem","ScrollArea","factory","classNames","className","styles","unstyled","vars","viewportProps","viewportRef","onScrollPositionChange","offsetScrollbars","scrollbarHovered","setScrollbarHovered","getStyles","useStyles","name","classes","onScroll","_ref2","currentTarget","onMouseEnter","onMouseLeave","ScrollAreaAutosize","variant","flexDirection","flex","Autosize","DirectionContext","createContext","toggleDirection","setDirection","useContext"],"sourceRoot":""}