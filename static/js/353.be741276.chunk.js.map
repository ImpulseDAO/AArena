{"version":3,"file":"static/js/353.be741276.chunk.js","mappings":"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","sources":["../node_modules/lodash/_Symbol.js","../node_modules/lodash/_arrayMap.js","../node_modules/lodash/_asciiToArray.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/_baseSlice.js","../node_modules/lodash/_baseToString.js","../node_modules/lodash/_castSlice.js","../node_modules/lodash/_createCaseFirst.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_hasUnicode.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_root.js","../node_modules/lodash/_stringToArray.js","../node_modules/lodash/_unicodeToArray.js","../node_modules/lodash/capitalize.js","../node_modules/lodash/isArray.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/isSymbol.js","../node_modules/lodash/toString.js","../node_modules/lodash/upperFirst.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js","../node_modules/use-sync-external-store/shim/index.js","../node_modules/use-sync-external-store/shim/with-selector.js","../node_modules/@mantine/core/src/components/Anchor/Anchor.tsx","../node_modules/@mantine/core/src/components/Badge/Badge.tsx","../node_modules/@mantine/core/src/components/InlineInput/InlineInput.tsx","../node_modules/@mantine/core/src/components/Radio/RadioGroup.context.ts","../node_modules/@mantine/core/src/components/InputsGroupFieldset/InputsGroupFieldset.tsx","../node_modules/@mantine/core/src/components/Radio/RadioGroup/RadioGroup.tsx","../node_modules/@mantine/core/src/components/Radio/RadioIcon.tsx","../node_modules/@mantine/core/src/components/Radio/Radio.tsx","../node_modules/@mantine/core/src/components/Table/Table.context.ts","../node_modules/@mantine/core/src/components/Table/Table.components.tsx","../node_modules/@mantine/core/src/components/Table/TableDataRenderer.tsx","../node_modules/@mantine/core/src/components/Table/TableScrollContainer.tsx","../node_modules/@mantine/core/src/components/Table/Table.tsx","../node_modules/effector-react/effector-react/createWatch.ts","../node_modules/effector-react/effector-react/apiBase.ts","../node_modules/effector-react/effector-react/scope.ts","../node_modules/effector-react/effector-react/nossr.ts","../node_modules/effector-react/effector-react/throw.ts","../node_modules/effector-react/effector-react/useIsomorphicLayoutEffect.ts","../node_modules/effector/effector/collection.ts","../node_modules/effector/effector/throw.ts","../node_modules/effector/effector/createNode.ts","../node_modules/effector/effector/tag.ts","../node_modules/effector/effector/kernel.ts","../node_modules/effector/effector/naming.ts","../node_modules/effector/effector/config.ts","../node_modules/effector/effector/template.ts","../node_modules/effector/effector/createUnit.ts","../node_modules/effector/effector/combine.ts","../node_modules/effector/effector/defer.ts","../node_modules/effector/effector/merge.ts","../node_modules/effector/effector/sample.ts","../node_modules/effector/effector/fork/scopeBind.ts","../node_modules/effector/effector/observable.ts","../node_modules/effector/effector/getter.ts","../node_modules/effector/effector/validate.ts","../node_modules/effector/effector/id.ts","../node_modules/effector/effector/region.ts","../node_modules/effector/effector/own.ts","../node_modules/effector/effector/is.ts","../node_modules/effector/effector/caller.ts","../node_modules/effector/effector/step.ts","../node_modules/effector/effector/stateRef.ts","../node_modules/effector/effector/clearNode.ts","../node_modules/effector/effector/subscription.ts","../node_modules/effector/effector/forward.ts","../node_modules/effector/effector/watch.ts","../node_modules/effector/effector/createEffect.ts"],"sourcesContent":["var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\nmodule.exports = asciiToArray;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseSlice = require('./_baseSlice');\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\nmodule.exports = castSlice;\n","var castSlice = require('./_castSlice'),\n    hasUnicode = require('./_hasUnicode'),\n    stringToArray = require('./_stringToArray'),\n    toString = require('./toString');\n\n/**\n * Creates a function like `_.lowerFirst`.\n *\n * @private\n * @param {string} methodName The name of the `String` case method to use.\n * @returns {Function} Returns the new case function.\n */\nfunction createCaseFirst(methodName) {\n  return function(string) {\n    string = toString(string);\n\n    var strSymbols = hasUnicode(string)\n      ? stringToArray(string)\n      : undefined;\n\n    var chr = strSymbols\n      ? strSymbols[0]\n      : string.charAt(0);\n\n    var trailing = strSymbols\n      ? castSlice(strSymbols, 1).join('')\n      : string.slice(1);\n\n    return chr[methodName]() + trailing;\n  };\n}\n\nmodule.exports = createCaseFirst;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\nmodule.exports = hasUnicode;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var asciiToArray = require('./_asciiToArray'),\n    hasUnicode = require('./_hasUnicode'),\n    unicodeToArray = require('./_unicodeToArray');\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\nmodule.exports = stringToArray;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\nmodule.exports = unicodeToArray;\n","var toString = require('./toString'),\n    upperFirst = require('./upperFirst');\n\n/**\n * Converts the first character of `string` to upper case and the remaining\n * to lower case.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to capitalize.\n * @returns {string} Returns the capitalized string.\n * @example\n *\n * _.capitalize('FRED');\n * // => 'Fred'\n */\nfunction capitalize(string) {\n  return upperFirst(toString(string).toLowerCase());\n}\n\nmodule.exports = capitalize;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var createCaseFirst = require('./_createCaseFirst');\n\n/**\n * Converts the first character of `string` to upper case.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.upperFirst('fred');\n * // => 'Fred'\n *\n * _.upperFirst('FRED');\n * // => 'FRED'\n */\nvar upperFirst = createCaseFirst('toUpperCase');\n\nmodule.exports = upperFirst;\n","/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var h=require(\"react\"),n=require(\"use-sync-external-store/shim\");function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\nexports.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\nu(function(){f.hasValue=!0;f.value=d},[d]);w(d);return d};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import React from 'react';\nimport cx from 'clsx';\nimport { polymorphicFactory, PolymorphicFactory, useProps } from '../../core';\nimport { Text, TextCssVariables, TextProps, TextStylesNames, TextVariant } from '../Text';\nimport classes from './Anchor.module.css';\n\nexport type AnchorStylesNames = TextStylesNames;\nexport type AnchorVariant = TextVariant;\nexport type AnchorCssVariables = TextCssVariables;\n\nexport interface AnchorProps extends Omit<TextProps, 'span'> {\n  /** Determines in which cases link should have `text-decoration: underline` styles, `hover` by default */\n  underline?: 'always' | 'hover' | 'never';\n}\n\nexport type AnchorFactory = PolymorphicFactory<{\n  props: AnchorProps;\n  defaultComponent: 'a';\n  defaultRef: HTMLAnchorElement;\n  stylesNames: AnchorStylesNames;\n  vars: AnchorCssVariables;\n  variant: AnchorVariant;\n}>;\n\nconst defaultProps: Partial<AnchorProps> = {\n  underline: 'hover',\n};\n\nexport const Anchor = polymorphicFactory<AnchorFactory>((props, ref) => {\n  const { underline, className, unstyled, ...others } = useProps('Anchor', defaultProps, props);\n  return (\n    <Text\n      component=\"a\"\n      ref={ref}\n      className={cx({ [classes.root]: !unstyled }, className)}\n      {...others}\n      mod={{ underline }}\n      __staticSelector=\"Anchor\"\n      unstyled={unstyled}\n    />\n  );\n});\n\nAnchor.classes = classes;\nAnchor.displayName = '@mantine/core/Anchor';\n","import React from 'react';\nimport {\n  Box,\n  BoxProps,\n  createVarsResolver,\n  getRadius,\n  getSize,\n  getThemeColor,\n  MantineColor,\n  MantineGradient,\n  MantineRadius,\n  MantineSize,\n  polymorphicFactory,\n  PolymorphicFactory,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../core';\nimport classes from './Badge.module.css';\n\nexport type BadgeStylesNames = 'root' | 'section' | 'label';\nexport type BadgeVariant =\n  | 'filled'\n  | 'light'\n  | 'outline'\n  | 'dot'\n  | 'transparent'\n  | 'white'\n  | 'default'\n  | 'gradient';\n\nexport type BadgeCssVariables = {\n  root:\n    | '--badge-height'\n    | '--badge-padding-x'\n    | '--badge-fz'\n    | '--badge-radius'\n    | '--badge-bg'\n    | '--badge-color'\n    | '--badge-bd'\n    | '--badge-dot-color';\n};\n\nexport interface BadgeProps extends BoxProps, StylesApiProps<BadgeFactory> {\n  /** Controls `font-size`, `height` and horizontal `padding`, `'md'` by default */\n  size?: MantineSize | (string & {});\n\n  /** If set, badge `min-width` becomes equal to its `height` and horizontal padding is removed */\n  circle?: boolean;\n\n  /** Key of `theme.radius` or any valid CSS value to set `border-radius`, `'xl'` by default */\n  radius?: MantineRadius;\n\n  /** Key of `theme.colors` or any valid CSS color, `theme.primaryColor` by default */\n  color?: MantineColor;\n\n  /** Gradient configuration used when `variant=\"gradient\"`, default value is `theme.defaultGradient` */\n  gradient?: MantineGradient;\n\n  /** Content displayed on the left side of the badge label */\n  leftSection?: React.ReactNode;\n\n  /** Content displayed on the right side of the badge label */\n  rightSection?: React.ReactNode;\n\n  /** Determines whether Badge should take 100% of its parent width, `false` by default */\n  fullWidth?: boolean;\n\n  /** Main badge content */\n  children?: React.ReactNode;\n\n  /** Determines whether text color with filled variant should depend on `background-color`. If luminosity of the `color` prop is less than `theme.luminosityThreshold`, then `theme.white` will be used for text color, otherwise `theme.black`. Overrides `theme.autoContrast`. */\n  autoContrast?: boolean;\n}\n\nexport type BadgeFactory = PolymorphicFactory<{\n  props: BadgeProps;\n  defaultRef: HTMLDivElement;\n  defaultComponent: 'div';\n  stylesNames: BadgeStylesNames;\n  vars: BadgeCssVariables;\n  variant: BadgeVariant;\n}>;\n\nconst defaultProps: Partial<BadgeProps> = {};\n\nconst varsResolver = createVarsResolver<BadgeFactory>(\n  (theme, { radius, color, gradient, variant, size, autoContrast }) => {\n    const colors = theme.variantColorResolver({\n      color: color || theme.primaryColor,\n      theme,\n      gradient,\n      variant: variant || 'filled',\n      autoContrast,\n    });\n\n    return {\n      root: {\n        '--badge-height': getSize(size, 'badge-height'),\n        '--badge-padding-x': getSize(size, 'badge-padding-x'),\n        '--badge-fz': getSize(size, 'badge-fz'),\n        '--badge-radius': radius === undefined ? undefined : getRadius(radius),\n        '--badge-bg': color || variant ? colors.background : undefined,\n        '--badge-color': color || variant ? colors.color : undefined,\n        '--badge-bd': color || variant ? colors.border : undefined,\n        '--badge-dot-color': variant === 'dot' ? getThemeColor(color, theme) : undefined,\n      },\n    };\n  }\n);\n\nexport const Badge = polymorphicFactory<BadgeFactory>((_props, ref) => {\n  const props = useProps('Badge', defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    vars,\n    radius,\n    color,\n    gradient,\n    leftSection,\n    rightSection,\n    children,\n    variant,\n    fullWidth,\n    autoContrast,\n    circle,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<BadgeFactory>({\n    name: 'Badge',\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n  });\n\n  return (\n    <Box\n      variant={variant}\n      mod={{ block: fullWidth, circle }}\n      {...getStyles('root', { variant })}\n      ref={ref}\n      {...others}\n    >\n      {leftSection && (\n        <span {...getStyles('section')} data-position=\"left\">\n          {leftSection}\n        </span>\n      )}\n      <span {...getStyles('label')}>{children}</span>\n      {rightSection && (\n        <span {...getStyles('section')} data-position=\"right\">\n          {rightSection}\n        </span>\n      )}\n    </Box>\n  );\n});\n\nBadge.classes = classes;\nBadge.displayName = '@mantine/core/Badge';\n","import React, { forwardRef } from 'react';\nimport {\n  Box,\n  BoxProps,\n  ElementProps,\n  Factory,\n  getFontSize,\n  getSize,\n  MantineSize,\n  StylesApiProps,\n  useStyles,\n} from '../../core';\nimport { Input } from '../Input';\nimport classes from './InlineInput.module.css';\n\nexport const InlineInputClasses = classes;\n\nexport type InlineInputStylesNames =\n  | 'root'\n  | 'body'\n  | 'labelWrapper'\n  | 'label'\n  | 'description'\n  | 'error';\n\nexport interface InlineInputProps\n  extends BoxProps,\n    StylesApiProps<InlineInputFactory>,\n    ElementProps<'div'> {\n  __staticSelector: string;\n  __stylesApiProps: Record<string, any>;\n  label: React.ReactNode;\n  description: React.ReactNode;\n  id: string;\n  disabled: boolean | undefined;\n  error: React.ReactNode;\n  size: MantineSize | (string & {}) | undefined;\n  labelPosition?: 'left' | 'right';\n}\n\nexport type InlineInputFactory = Factory<{\n  props: any;\n  stylesNames: InlineInputStylesNames;\n}>;\n\nexport const InlineInput = forwardRef<HTMLDivElement, InlineInputProps>(\n  (\n    {\n      __staticSelector,\n      __stylesApiProps,\n      className,\n      classNames,\n      styles,\n      unstyled,\n      children,\n      label,\n      description,\n      id,\n      disabled,\n      error,\n      size,\n      labelPosition = 'left',\n      variant,\n      style,\n      vars,\n      ...others\n    },\n    ref\n  ) => {\n    const getStyles = useStyles<InlineInputFactory>({\n      name: __staticSelector,\n      props: __stylesApiProps,\n      className,\n      style,\n      classes,\n      classNames,\n      styles,\n      unstyled,\n    });\n\n    return (\n      <Box\n        {...getStyles('root')}\n        ref={ref}\n        __vars={{\n          '--label-fz': getFontSize(size),\n          '--label-lh': getSize(size, 'label-lh'),\n        }}\n        mod={{ 'label-position': labelPosition }}\n        variant={variant}\n        size={size}\n        {...others}\n      >\n        <div {...getStyles('body')}>\n          {children}\n\n          <div {...getStyles('labelWrapper')} data-disabled={disabled || undefined}>\n            {label && (\n              <label {...getStyles('label')} data-disabled={disabled || undefined} htmlFor={id}>\n                {label}\n              </label>\n            )}\n\n            {description && (\n              <Input.Description size={size} __inheritStyles={false} {...getStyles('description')}>\n                {description}\n              </Input.Description>\n            )}\n\n            {error && error !== 'boolean' && (\n              <Input.Error size={size} __inheritStyles={false} {...getStyles('error')}>\n                {error}\n              </Input.Error>\n            )}\n          </div>\n        </div>\n      </Box>\n    );\n  }\n);\n\nInlineInput.displayName = '@mantine/core/InlineInput';\n","import { createOptionalContext, MantineSize } from '../../core';\n\ninterface RadioGroupContextValue {\n  size: MantineSize | undefined;\n  value: string;\n  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void;\n  name: string;\n}\n\nexport const [RadioGroupProvider, useRadioGroupContext] =\n  createOptionalContext<RadioGroupContextValue>();\n","import React from 'react';\nimport { useInputWrapperContext } from '../Input';\n\ninterface InputsGroupFieldsetProps {\n  children: React.ReactNode;\n  role: 'radiogroup' | 'group';\n}\n\nexport function InputsGroupFieldset({ children, role }: InputsGroupFieldsetProps) {\n  const ctx = useInputWrapperContext();\n\n  if (!ctx) {\n    return <>{children}</>;\n  }\n\n  return (\n    <div role={role} aria-labelledby={ctx.labelId} aria-describedby={ctx.describedBy}>\n      {children}\n    </div>\n  );\n}\n","import React from 'react';\nimport { useId, useUncontrolled } from '@mantine/hooks';\nimport { factory, Factory, MantineSize, useProps } from '../../../core';\nimport { Input, InputWrapperProps, InputWrapperStylesNames } from '../../Input';\nimport { InputsGroupFieldset } from '../../InputsGroupFieldset';\nimport { RadioGroupProvider } from '../RadioGroup.context';\n\nexport type RadioGroupStylesNames = InputWrapperStylesNames;\n\nexport interface RadioGroupProps extends Omit<InputWrapperProps, 'onChange'> {\n  /** `Radio` components and any other elements */\n  children: React.ReactNode;\n\n  /** Controlled component value */\n  value?: string;\n\n  /** Default value for uncontrolled component */\n  defaultValue?: string;\n\n  /** Called when value changes */\n  onChange?: (value: string) => void;\n\n  /** Props passed down to the `Input.Wrapper` */\n  wrapperProps?: Record<string, any>;\n\n  /** Controls size of the `Input.Wrapper`, `'sm'` by default */\n  size?: MantineSize;\n\n  /** `name` attribute of child radio inputs. By default, `name` is generated randomly. */\n  name?: string;\n}\n\nexport type RadioGroupFactory = Factory<{\n  props: RadioGroupProps;\n  ref: HTMLDivElement;\n  stylesNames: RadioGroupStylesNames;\n}>;\n\nconst defaultProps: Partial<RadioGroupProps> = {};\n\nexport const RadioGroup = factory<RadioGroupFactory>((props, ref) => {\n  const { value, defaultValue, onChange, size, wrapperProps, children, name, ...others } = useProps(\n    'RadioGroup',\n    defaultProps,\n    props\n  );\n\n  const _name = useId(name);\n\n  const [_value, setValue] = useUncontrolled({\n    value,\n    defaultValue,\n    finalValue: '',\n    onChange,\n  });\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) =>\n    setValue(event.currentTarget.value);\n\n  return (\n    <RadioGroupProvider value={{ value: _value, onChange: handleChange, size, name: _name }}>\n      <Input.Wrapper\n        size={size}\n        ref={ref}\n        {...wrapperProps}\n        {...others}\n        labelElement=\"div\"\n        __staticSelector=\"RadioGroup\"\n      >\n        <InputsGroupFieldset role=\"radiogroup\">{children}</InputsGroupFieldset>\n      </Input.Wrapper>\n    </RadioGroupProvider>\n  );\n});\n\nRadioGroup.classes = Input.Wrapper.classes;\nRadioGroup.displayName = '@mantine/core/RadioGroup';\n","import React from 'react';\nimport { rem } from '../../core';\n\nexport interface RadioIconProps extends React.ComponentPropsWithoutRef<'svg'> {\n  size?: string | number;\n}\n\nexport function RadioIcon({ size, style, ...others }: RadioIconProps) {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      fill=\"none\"\n      viewBox=\"0 0 5 5\"\n      style={{ width: rem(size), height: rem(size), ...style }}\n      aria-hidden\n      {...others}\n    >\n      <circle cx=\"2.5\" cy=\"2.5\" r=\"2.5\" fill=\"currentColor\" />\n    </svg>\n  );\n}\n","import React from 'react';\nimport { useId } from '@mantine/hooks';\nimport {\n  Box,\n  BoxProps,\n  createVarsResolver,\n  ElementProps,\n  extractStyleProps,\n  factory,\n  Factory,\n  getContrastColor,\n  getRadius,\n  getSize,\n  getThemeColor,\n  MantineColor,\n  MantineRadius,\n  MantineSize,\n  parseThemeColor,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../core';\nimport { InlineInput, InlineInputStylesNames } from '../InlineInput';\nimport { useRadioGroupContext } from './RadioGroup.context';\nimport { RadioGroup } from './RadioGroup/RadioGroup';\nimport { RadioIcon, RadioIconProps } from './RadioIcon';\nimport classes from './Radio.module.css';\n\nexport type RadioVariant = 'filled' | 'outline';\nexport type RadioStylesNames = InlineInputStylesNames | 'inner' | 'radio' | 'icon';\nexport type RadioCssVariables = {\n  root:\n    | '--radio-size'\n    | '--radio-radius'\n    | '--radio-color'\n    | '--radio-icon-color'\n    | '--radio-icon-size';\n};\n\nexport interface RadioProps\n  extends BoxProps,\n    StylesApiProps<RadioFactory>,\n    ElementProps<'input', 'size'> {\n  /** Content of the `label` associated with the radio */\n  label?: React.ReactNode;\n\n  /** Key of `theme.colors` or any valid CSS color to set input color in checked state, `theme.primaryColor` by default */\n  color?: MantineColor;\n\n  /** Controls size of the component, `'sm'` by default */\n  size?: MantineSize;\n\n  /** A component that replaces default check icon */\n  icon?: React.FC<RadioIconProps>;\n\n  /** Props passed down to the root element */\n  wrapperProps?: Record<string, any>;\n\n  /** Position of the label relative to the input, `'right'` by default */\n  labelPosition?: 'left' | 'right';\n\n  /** Description displayed below the label */\n  description?: React.ReactNode;\n\n  /** Error displayed below the label */\n  error?: React.ReactNode;\n\n  /** Key of `theme.radius` or any valid CSS value to set `border-radius,` \"xl\" by default */\n  radius?: MantineRadius;\n\n  /** Assigns ref of the root element */\n  rootRef?: React.ForwardedRef<HTMLDivElement>;\n\n  /** Key of `theme.colors` or any valid CSS color to set icon color, by default value depends on `theme.autoContrast` */\n  iconColor?: MantineColor;\n\n  /** Determines whether icon color with filled variant should depend on `background-color`. If luminosity of the `color` prop is less than `theme.luminosityThreshold`, then `theme.white` will be used for text color, otherwise `theme.black`. Overrides `theme.autoContrast`. */\n  autoContrast?: boolean;\n}\n\nexport type RadioFactory = Factory<{\n  props: RadioProps;\n  ref: HTMLInputElement;\n  stylesNames: RadioStylesNames;\n  vars: RadioCssVariables;\n  variant: RadioVariant;\n  staticComponents: {\n    Group: typeof RadioGroup;\n  };\n}>;\n\nconst defaultProps: Partial<RadioProps> = {\n  labelPosition: 'right',\n};\n\nconst varsResolver = createVarsResolver<RadioFactory>(\n  (theme, { size, radius, color, iconColor, variant, autoContrast }) => {\n    const parsedColor = parseThemeColor({ color: color || theme.primaryColor, theme });\n    const outlineColor =\n      parsedColor.isThemeColor && parsedColor.shade === undefined\n        ? `var(--mantine-color-${parsedColor.color}-outline)`\n        : parsedColor.color;\n\n    return {\n      root: {\n        '--radio-size': getSize(size, 'radio-size'),\n        '--radio-radius': radius === undefined ? undefined : getRadius(radius),\n        '--radio-color': variant === 'outline' ? outlineColor : getThemeColor(color, theme),\n        '--radio-icon-color': iconColor\n          ? getThemeColor(iconColor, theme)\n          : autoContrast\n            ? getContrastColor({ color, theme })\n            : undefined,\n        '--radio-icon-size': getSize(size, 'radio-icon-size'),\n      },\n    };\n  }\n);\n\nexport const Radio = factory<RadioFactory>((_props, ref) => {\n  const props = useProps('Radio', defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    vars,\n    id,\n    size,\n    label,\n    labelPosition,\n    description,\n    error,\n    radius,\n    color,\n    variant,\n    disabled,\n    wrapperProps,\n    icon: Icon = RadioIcon,\n    rootRef,\n    iconColor,\n    onChange,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<RadioFactory>({\n    name: 'Radio',\n    classes,\n    props,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n  });\n\n  const ctx = useRadioGroupContext();\n\n  const contextSize = ctx?.size ?? size;\n  const componentSize = props.size ? size : contextSize;\n\n  const { styleProps, rest } = extractStyleProps(others);\n  const uuid = useId(id);\n\n  const contextProps = ctx\n    ? {\n        checked: ctx.value === rest.value,\n        name: rest.name ?? ctx.name,\n        onChange: (event: React.ChangeEvent<HTMLInputElement>) => {\n          ctx.onChange(event);\n          onChange?.(event);\n        },\n      }\n    : {};\n\n  return (\n    <InlineInput\n      {...getStyles('root')}\n      __staticSelector=\"Radio\"\n      __stylesApiProps={props}\n      id={uuid}\n      size={componentSize}\n      labelPosition={labelPosition}\n      label={label}\n      description={description}\n      error={error}\n      disabled={disabled}\n      classNames={classNames}\n      styles={styles}\n      unstyled={unstyled}\n      data-checked={contextProps.checked || undefined}\n      variant={variant}\n      ref={rootRef}\n      {...styleProps}\n      {...wrapperProps}\n    >\n      <Box {...getStyles('inner')} mod={{ 'label-position': labelPosition }}>\n        <Box\n          {...getStyles('radio', { focusable: true, variant })}\n          onChange={onChange}\n          {...rest}\n          {...contextProps}\n          component=\"input\"\n          mod={{ error: !!error }}\n          ref={ref}\n          id={uuid}\n          disabled={disabled}\n          type=\"radio\"\n        />\n        <Icon {...getStyles('icon')} aria-hidden />\n      </Box>\n    </InlineInput>\n  );\n});\n\nRadio.classes = classes;\nRadio.displayName = '@mantine/core/Radio';\nRadio.Group = RadioGroup;\n","import { createSafeContext, GetStylesApi } from '../../core';\nimport type { TableFactory } from './Table';\n\nexport interface TableContextValue {\n  getStyles: GetStylesApi<TableFactory>;\n  stickyHeader: boolean | undefined;\n  striped: 'odd' | 'even' | undefined;\n  highlightOnHover: boolean | undefined;\n  withColumnBorders: boolean | undefined;\n  withRowBorders: boolean | undefined;\n  captionSide: 'top' | 'bottom';\n}\n\nexport const [TableProvider, useTableContext] = createSafeContext<TableContextValue>(\n  'Table component was not found in the tree'\n);\n","import React from 'react';\nimport {\n  Box,\n  BoxProps,\n  CompoundStylesApiProps,\n  ElementProps,\n  factory,\n  Factory,\n  FactoryPayload,\n  useProps,\n} from '../../core';\nimport type { TableFactory } from './Table';\nimport { TableContextValue, useTableContext } from './Table.context';\nimport classes from './Table.module.css';\n\nexport interface TableElementProps<Selector extends string>\n  extends BoxProps,\n    CompoundStylesApiProps<Omit<TableFactory, 'stylesNames'> & { stylesNames: Selector }> {}\n\nexport interface TableThProps extends TableElementProps<'th'>, ElementProps<'th'> {}\nexport interface TableTdProps extends TableElementProps<'td'>, ElementProps<'td'> {}\nexport interface TableTrProps extends TableElementProps<'tr'>, ElementProps<'tr'> {}\nexport interface TableTheadProps extends TableElementProps<'thead'>, ElementProps<'thead'> {}\nexport interface TableTbodyProps extends TableElementProps<'tbody'>, ElementProps<'tbody'> {}\nexport interface TableTfootProps extends TableElementProps<'tfoot'>, ElementProps<'tfoot'> {}\nexport interface TableCaptionProps extends TableElementProps<'caption'>, ElementProps<'caption'> {}\n\nexport type TableThFactory = Factory<{\n  props: TableThProps;\n  ref: HTMLTableCellElement;\n  stylesNames: 'th';\n  compound: true;\n}>;\n\nexport type TableTdFactory = Factory<{\n  props: TableTdProps;\n  ref: HTMLTableCellElement;\n  stylesNames: 'td';\n  compound: true;\n}>;\n\nexport type TableTrFactory = Factory<{\n  props: TableTrProps;\n  ref: HTMLTableRowElement;\n  stylesNames: 'tr';\n  compound: true;\n}>;\n\nexport type TableTheadFactory = Factory<{\n  props: TableTheadProps;\n  ref: HTMLTableSectionElement;\n  stylesNames: 'thead';\n  compound: true;\n}>;\n\nexport type TableTbodyFactory = Factory<{\n  props: TableTbodyProps;\n  ref: HTMLTableSectionElement;\n  stylesNames: 'tbody';\n  compound: true;\n}>;\n\nexport type TableTfootFactory = Factory<{\n  props: TableTfootProps;\n  ref: HTMLTableSectionElement;\n  stylesNames: 'tfoot';\n  compound: true;\n}>;\n\nexport type TableCaptionFactory = Factory<{\n  props: TableCaptionProps;\n  ref: HTMLTableCaptionElement;\n  stylesNames: 'caption';\n  compound: true;\n}>;\n\ninterface TableElementOptions {\n  columnBorder?: true;\n  rowBorder?: true;\n  striped?: true;\n  highlightOnHover?: true;\n  captionSide?: true;\n  stickyHeader?: true;\n}\n\nfunction getDataAttributes(ctx: TableContextValue, options?: TableElementOptions) {\n  if (!options) {\n    return undefined;\n  }\n\n  const data: Record<string, boolean | string> = {};\n\n  if (options.columnBorder && ctx.withColumnBorders) {\n    data['data-with-column-border'] = true;\n  }\n\n  if (options.rowBorder && ctx.withRowBorders) {\n    data['data-with-row-border'] = true;\n  }\n\n  if (options.striped && ctx.striped) {\n    data['data-striped'] = ctx.striped;\n  }\n\n  if (options.highlightOnHover && ctx.highlightOnHover) {\n    data['data-hover'] = true;\n  }\n\n  if (options.captionSide && ctx.captionSide) {\n    data['data-side'] = ctx.captionSide;\n  }\n\n  if (options.stickyHeader && ctx.stickyHeader) {\n    data['data-sticky'] = true;\n  }\n\n  return data;\n}\n\nexport function tableElement<Factory extends FactoryPayload>(\n  element: 'th' | 'td' | 'tr' | 'thead' | 'tbody' | 'tfoot' | 'caption',\n  options?: TableElementOptions\n) {\n  const name = `Table${element.charAt(0).toUpperCase()}${element.slice(1)}`;\n  const Component = factory<Factory>((_props, ref) => {\n    const props = useProps(name, {}, _props);\n    const { classNames, className, style, styles, ...others } = props;\n\n    const ctx = useTableContext();\n\n    return (\n      <Box\n        component={element}\n        ref={ref}\n        {...getDataAttributes(ctx, options)}\n        {...ctx.getStyles(element, { className, classNames, style, styles, props })}\n        {...others}\n      />\n    );\n  });\n\n  Component.displayName = `@mantine/core/${name}`;\n  Component.classes = classes;\n  return Component;\n}\n\nexport const TableTh = tableElement<TableThFactory>('th', { columnBorder: true });\nexport const TableTd = tableElement<TableTdFactory>('td', { columnBorder: true });\nexport const TableTr = tableElement<TableTrFactory>('tr', {\n  rowBorder: true,\n  striped: true,\n  highlightOnHover: true,\n});\nexport const TableThead = tableElement<TableTheadFactory>('thead', { stickyHeader: true });\nexport const TableTbody = tableElement<TableTbodyFactory>('tbody');\nexport const TableTfoot = tableElement<TableTfootFactory>('tfoot');\nexport const TableCaption = tableElement<TableCaptionFactory>('caption', { captionSide: true });\n","import React from 'react';\nimport type { TableData } from './Table';\nimport {\n  TableCaption,\n  TableTbody,\n  TableTd,\n  TableTfoot,\n  TableTh,\n  TableThead,\n  TableTr,\n} from './Table.components';\n\nexport interface TableDataRendererProps {\n  data: TableData;\n}\n\nexport function TableDataRenderer({ data }: TableDataRendererProps) {\n  return (\n    <>\n      {data.caption && <TableCaption>{data.caption}</TableCaption>}\n\n      {data.head && (\n        <TableThead>\n          <TableTr>\n            {data.head.map((item, index) => (\n              <TableTh key={index}>{item}</TableTh>\n            ))}\n          </TableTr>\n        </TableThead>\n      )}\n\n      {data.body && (\n        <TableTbody>\n          {data.body.map((row, rowIndex) => (\n            <TableTr key={rowIndex}>\n              {row.map((item, index) => (\n                <TableTd key={index}>{item}</TableTd>\n              ))}\n            </TableTr>\n          ))}\n        </TableTbody>\n      )}\n\n      {data.foot && (\n        <TableTfoot>\n          <TableTr>\n            {data.foot.map((item, index) => (\n              <TableTh key={index}>{item}</TableTh>\n            ))}\n          </TableTr>\n        </TableTfoot>\n      )}\n    </>\n  );\n}\n\nTableDataRenderer.displayName = '@mantine/core/TableDataRenderer';\n","import React from 'react';\nimport {\n  Box,\n  BoxProps,\n  createVarsResolver,\n  ElementProps,\n  factory,\n  Factory,\n  rem,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../core';\nimport { ScrollArea } from '../ScrollArea';\nimport classes from './Table.module.css';\n\nexport type TableScrollContainerStylesNames = 'scrollContainer' | 'scrollContainerInner';\nexport type TableScrollContainerCssVariables = {\n  scrollContainer: '--table-min-width' | '--table-overflow';\n};\n\nexport interface TableScrollContainerProps\n  extends BoxProps,\n    StylesApiProps<TableScrollContainerFactory>,\n    ElementProps<'div'> {\n  /** `min-width` of the `Table` at which it should become scrollable */\n  minWidth: React.CSSProperties['minWidth'];\n\n  /** Type of the scroll container, `native` to use native scrollbars, `scrollarea` to use `ScrollArea` component, `scrollarea` by default */\n  type?: 'native' | 'scrollarea';\n}\n\nexport type TableScrollContainerFactory = Factory<{\n  props: TableScrollContainerProps;\n  ref: HTMLDivElement;\n  stylesNames: TableScrollContainerStylesNames;\n  vars: TableScrollContainerCssVariables;\n}>;\n\nconst defaultProps: Partial<TableScrollContainerProps> = {\n  type: 'scrollarea',\n};\n\nconst varsResolver = createVarsResolver<TableScrollContainerFactory>((_, { minWidth, type }) => ({\n  scrollContainer: {\n    '--table-min-width': rem(minWidth),\n    '--table-overflow': type === 'native' ? 'auto' : undefined,\n  },\n}));\n\nexport const TableScrollContainer = factory<TableScrollContainerFactory>((_props, ref) => {\n  const props = useProps('TableScrollContainer', defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    vars,\n    children,\n    minWidth,\n    type,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<TableScrollContainerFactory>({\n    name: 'TableScrollContainer',\n    classes,\n    props,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n    rootSelector: 'scrollContainer',\n  });\n\n  return (\n    <Box<any>\n      component={type === 'scrollarea' ? ScrollArea : 'div'}\n      {...(type === 'scrollarea' ? { offsetScrollbars: 'x' } : {})}\n      ref={ref}\n      {...getStyles('scrollContainer')}\n      {...others}\n    >\n      <div {...getStyles('scrollContainerInner')}>{children}</div>\n    </Box>\n  );\n});\n\nTableScrollContainer.classes = classes;\nTableScrollContainer.displayName = '@mantine/core/TableScrollContainer';\n","import React from 'react';\nimport {\n  Box,\n  BoxProps,\n  createVarsResolver,\n  ElementProps,\n  factory,\n  Factory,\n  getSpacing,\n  getThemeColor,\n  MantineColor,\n  MantineSpacing,\n  rem,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../core';\nimport {\n  TableCaption,\n  TableTbody,\n  TableTd,\n  TableTfoot,\n  TableTh,\n  TableThead,\n  TableTr,\n} from './Table.components';\nimport { TableProvider } from './Table.context';\nimport { TableDataRenderer } from './TableDataRenderer';\nimport { TableScrollContainer } from './TableScrollContainer';\nimport classes from './Table.module.css';\n\nexport type TableStylesNames =\n  | 'table'\n  | 'thead'\n  | 'tbody'\n  | 'tfoot'\n  | 'tr'\n  | 'th'\n  | 'td'\n  | 'caption';\n\nexport type TableCssVariables = {\n  table:\n    | '--table-layout'\n    | '--table-border-color'\n    | '--table-caption-side'\n    | '--table-horizontal-spacing'\n    | '--table-vertical-spacing'\n    | '--table-striped-color'\n    | '--table-highlight-on-hover-color'\n    | '--table-sticky-header-offset';\n};\n\nexport interface TableData {\n  head?: React.ReactNode[];\n  body?: React.ReactNode[][];\n  foot?: React.ReactNode[];\n  caption?: string;\n}\n\nexport interface TableProps extends BoxProps, StylesApiProps<TableFactory>, ElementProps<'table'> {\n  /** Value of `table-layout` style, `auto` by default */\n  layout?: React.CSSProperties['tableLayout'];\n\n  /** Determines on which side `Table.Caption` is displayed, `bottom` by default */\n  captionSide?: 'top' | 'bottom';\n\n  /** Color of table borders, key of `theme.colors` or any valid CSS color */\n  borderColor?: MantineColor;\n\n  /** Determines whether the table should have outer border, `false` by default */\n  withTableBorder?: boolean;\n\n  /** Determines whether the table should have borders between columns, `false` by default */\n  withColumnBorders?: boolean;\n\n  /** Determines whether the table should have borders between rows, `true` by default */\n  withRowBorders?: boolean;\n\n  /** Horizontal cells spacing, key of `theme.spacing` or any valid CSS value for padding, numbers are converted to rem, default value is `xs` */\n  horizontalSpacing?: MantineSpacing;\n\n  /** Vertical cells spacing, key of `theme.spacing` or any valid CSS value for padding, numbers are converted to rem, default value is `xs` */\n  verticalSpacing?: MantineSpacing;\n\n  /** Determines whether every odd/even row background should be changed to `strippedColor`, if set to `true`, then `odd` value will be used, `false` by default  */\n  striped?: boolean | 'odd' | 'even';\n\n  /** Background color of striped rows, key of `theme.colors` or any valid CSS color */\n  stripedColor?: MantineColor;\n\n  /** Determines whether table rows background should change to `highlightOnHoverColor` when hovered, `false` by default */\n  highlightOnHover?: boolean;\n\n  /** Background color of table rows when hovered, key of `theme.colors` or any valid CSS color */\n  highlightOnHoverColor?: MantineColor;\n\n  /** Data that should be used to generate table, ignored if `children` prop is set */\n  data?: TableData;\n\n  /** Determines whether `Table.Thead` should be sticky, `false` by default */\n  stickyHeader?: boolean;\n\n  /** Offset from top at which `Table.Thead` should become sticky, `0` by default */\n  stickyHeaderOffset?: number | string;\n}\n\nexport type TableFactory = Factory<{\n  props: TableProps;\n  ref: HTMLTableElement;\n  stylesNames: TableStylesNames;\n  vars: TableCssVariables;\n  staticComponents: {\n    Thead: typeof TableThead;\n    Tbody: typeof TableTbody;\n    Tfoot: typeof TableTfoot;\n    Td: typeof TableTd;\n    Th: typeof TableTh;\n    Tr: typeof TableTr;\n    Caption: typeof TableCaption;\n    ScrollContainer: typeof TableScrollContainer;\n    DataRenderer: typeof TableDataRenderer;\n  };\n}>;\n\nconst defaultProps: Partial<TableProps> = {\n  withRowBorders: true,\n  verticalSpacing: 7,\n};\n\nconst varsResolver = createVarsResolver<TableFactory>(\n  (\n    theme,\n    {\n      layout,\n      captionSide,\n      horizontalSpacing,\n      verticalSpacing,\n      borderColor,\n      stripedColor,\n      highlightOnHoverColor,\n      striped,\n      highlightOnHover,\n      stickyHeaderOffset,\n      stickyHeader,\n    }\n  ) => ({\n    table: {\n      '--table-layout': layout,\n      '--table-caption-side': captionSide,\n      '--table-horizontal-spacing': getSpacing(horizontalSpacing),\n      '--table-vertical-spacing': getSpacing(verticalSpacing),\n      '--table-border-color': borderColor ? getThemeColor(borderColor, theme) : undefined,\n      '--table-striped-color':\n        striped && stripedColor ? getThemeColor(stripedColor, theme) : undefined,\n      '--table-highlight-on-hover-color':\n        highlightOnHover && highlightOnHoverColor\n          ? getThemeColor(highlightOnHoverColor, theme)\n          : undefined,\n      '--table-sticky-header-offset': stickyHeader ? rem(stickyHeaderOffset) : undefined,\n    },\n  })\n);\n\nexport const Table = factory<TableFactory>((_props, ref) => {\n  const props = useProps('Table', defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    vars,\n    horizontalSpacing,\n    verticalSpacing,\n    captionSide,\n    stripedColor,\n    highlightOnHoverColor,\n    striped,\n    highlightOnHover,\n    withColumnBorders,\n    withRowBorders,\n    withTableBorder,\n    borderColor,\n    layout,\n    variant,\n    data,\n    children,\n    stickyHeader,\n    stickyHeaderOffset,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<TableFactory>({\n    name: 'Table',\n    props,\n    className,\n    style,\n    classes,\n    classNames,\n    styles,\n    unstyled,\n    rootSelector: 'table',\n    vars,\n    varsResolver,\n  });\n\n  return (\n    <TableProvider\n      value={{\n        getStyles,\n        stickyHeader,\n        striped: striped === true ? 'odd' : striped || undefined,\n        highlightOnHover,\n        withColumnBorders,\n        withRowBorders,\n        captionSide: captionSide || 'bottom',\n      }}\n    >\n      <Box\n        component=\"table\"\n        variant={variant}\n        ref={ref}\n        mod={{ 'data-with-table-border': withTableBorder }}\n        {...getStyles('table')}\n        {...others}\n      >\n        {children || (!!data && <TableDataRenderer data={data} />)}\n      </Box>\n    </TableProvider>\n  );\n});\n\nTable.classes = classes;\nTable.displayName = '@mantine/core/Table';\nTable.Td = TableTd;\nTable.Th = TableTh;\nTable.Tr = TableTr;\nTable.Thead = TableThead;\nTable.Tbody = TableTbody;\nTable.Tfoot = TableTfoot;\nTable.Caption = TableCaption;\nTable.ScrollContainer = TableScrollContainer;\nTable.DataRenderer = TableDataRenderer;\n","import {Store, clearNode, step, createNode, Scope, Node, Cmd} from 'effector'\n\nexport function createWatch<T>(\n  store: Store<T>,\n  fn: (value: T) => any,\n  scope?: Scope,\n  batchStep?: Cmd,\n) {\n  const seq: Cmd[] = [\n    step.mov({\n      store: (store as any).stateRef,\n      to: 'stack',\n    }),\n    step.run({fn: (v) => fn(v)}),\n  ]\n  if (batchStep) seq.unshift(batchStep)\n  if (scope) {\n    const node = createNode({\n      node: seq,\n      meta: {\n        watchOp: \"store\"\n      },\n    })\n    const id = (store as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return () => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    }\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [store],\n      family: {owners: store},\n    })\n    return () => {\n      clearNode(node)\n    }\n  }\n}\n","import {Store, is, step, scopeBind, Scope, Unit, Event} from 'effector'\nimport React from 'react'\nimport {useSyncExternalStore} from 'use-sync-external-store/shim'\nimport {useSyncExternalStoreWithSelector} from 'use-sync-external-store/shim/with-selector'\nimport {throwError} from './throw'\nimport {createWatch} from './createWatch'\nimport {withDisplayName} from './withDisplayName'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {Gate} from './index.h'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst keysEqual = (a?: readonly any[], b?: readonly any[]) => {\n  if (!a || !b || a.length !== b.length) return false\n\n  let isEqual = true\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      isEqual = false\n      break\n    }\n  }\n\n  return isEqual\n}\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n  const currentValue = useSyncExternalStore(subscribe, read, read)\n\n  return currentValue\n}\n\nexport function useUnitBase<Shape extends {[key: string]: Unit<any>}>(\n  shape: Shape | {'@@unitShape': () => Shape},\n  scope?: Scope,\n) {\n  const isSingleUnit = is.unit(shape)\n  let normShape: {[key: string]: Unit<any>} = {}\n  if (isSingleUnit) {\n    normShape = {unit: shape}\n  } else if ('@@unitShape' in shape) {\n    if (typeof shape['@@unitShape'] === 'function') {\n      normShape = shape['@@unitShape']()\n    } else {\n      throwError('expect @@unitShape to be a function')\n    }\n  } else {\n    normShape = shape\n  }\n  const isList = Array.isArray(normShape)\n  const flagsRef = React.useRef({\n    stale: true,\n    justSubscribed: false,\n    scope,\n  })\n  const [eventsShape, storeKeys, storeValues, eventKeys, eventValues] =\n    React.useMemo(() => {\n      flagsRef.current.stale = true\n      const shape = Array.isArray(normShape) ? [] : ({} as any)\n      const storeKeys: string[] = []\n      const storeValues: Array<Store<any>> = []\n      const eventKeys: string[] = []\n      const eventValues: Array<Unit<any>> = []\n      for (const key in normShape) {\n        const unit = normShape[key]\n        if (!is.unit(unit)) throwError('expect useUnit argument to be a unit')\n        if (is.event(unit) || is.effect(unit)) {\n          shape[key] = scope ? scopeBind(unit as Event<any>, {scope}) : unit\n          eventKeys.push(key)\n          eventValues.push(unit)\n        } else {\n          shape[key] = null\n          storeKeys.push(key)\n          storeValues.push(unit as Store<any>)\n        }\n      }\n      return [shape, storeKeys, storeValues, eventKeys, eventValues]\n    }, [\n      flagsRef,\n      scope,\n      ...Object.keys(normShape),\n      ...Object.values(normShape),\n    ])\n  const stateRef = React.useRef({\n    value: eventsShape,\n    storeKeys,\n    eventKeys,\n    eventValues,\n  })\n  const subscribe = React.useCallback(\n    (cb: () => void) => {\n      const flags = flagsRef.current\n      flags.justSubscribed = true\n      const cbCaller = () => {\n        if (!flags.stale) {\n          flags.stale = true\n          cb()\n        }\n      }\n      const batchStep = step.compute({priority: 'sampler', batch: true})\n      const subs = storeValues.map(store =>\n        createWatch(store, cbCaller, scope, batchStep),\n      )\n      return () => {\n        subs.forEach(fn => fn())\n      }\n    },\n    [storeValues, scope, stateRef, flagsRef],\n  )\n  const read = React.useCallback(() => {\n    const state = stateRef.current\n    const flags = flagsRef.current\n    let resultValue\n    let changed = false\n    const oldVal = state.value\n    const oldStoreKeys = state.storeKeys\n    const oldEventKeys = state.eventKeys\n    const oldEventValues = state.eventValues\n    const scopeChanged = scope !== flags.scope\n    if (flags.stale || flags.justSubscribed || scopeChanged) {\n      changed = !flags.justSubscribed || scopeChanged\n      resultValue = isList ? [...eventsShape] : {...eventsShape}\n      if (\n        oldStoreKeys.length !== storeKeys.length ||\n        oldEventKeys.length !== eventKeys.length\n      ) {\n        changed = true\n      }\n      for (let i = 0; i < storeKeys.length; i++) {\n        const updatedValue = stateReader(storeValues[i], scope)\n        const key = storeKeys[i]\n        if (!changed) {\n          if (!oldStoreKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldVal[key] !== updatedValue\n          }\n        }\n        resultValue[key] = updatedValue\n      }\n      for (let i = 0; i < eventKeys.length; i++) {\n        const updatedValue = eventValues[i]\n        const key = eventKeys[i]\n        if (!changed) {\n          if (!oldEventKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldEventValues[oldEventKeys.indexOf(key)] !== updatedValue\n          }\n        }\n      }\n    }\n    if (changed) {\n      state.value = resultValue\n    }\n    state.storeKeys = storeKeys\n    state.eventKeys = eventKeys\n    state.eventValues = eventValues\n    flags.stale = false\n    flags.justSubscribed = !changed\n    flags.scope = scope\n    return isSingleUnit ? state.value.unit : state.value\n  }, [subscribe, storeValues, eventValues, scope, stateRef, flagsRef])\n  return useSyncExternalStore(subscribe, read, read)\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n          defaultValue?: Result\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let defaultValue: Result | undefined\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    ;({\n      fn,\n      store,\n      keys,\n      defaultValue,\n      updateFilter = basicUpdateFilter,\n    } = configOrStore as any)\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n\n  const stateRef = React.useRef<State>()\n  const valueRef = React.useRef<Result>()\n  const keysRef = React.useRef(keys)\n\n  const value = useSyncExternalStoreWithSelector(\n    subscribe,\n    read,\n    read,\n    state => {\n      if (stateRef.current !== state || !keysEqual(keysRef.current, keys)) {\n        let result = fn(state, keys)\n        if (result === undefined && defaultValue !== undefined) {\n          result = defaultValue\n        }\n        stateRef.current = state\n        keysRef.current = keys\n\n        /**\n         * skip update, if undefined\n         * just like original store or previous implementation\n         */\n        if (result !== undefined) {\n          valueRef.current = result\n        }\n      }\n\n      return valueRef.current as Result\n    },\n    (current, update) => !updateFilter(update, current),\n  )\n\n  return value\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: ((item: T) => string) | void\n  let placeholder: React.ReactNode | void\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    ;({fn, getKey, placeholder} = renderItem)\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    const listItems = useStoreBase(list, scope)\n    if (listItems.length === 0 && placeholder) return placeholder\n    return listItems.map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    if (length === 0 && placeholder) return placeholder\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n\nexport function useEventBase(eventObject: any, scope?: Scope) {\n  if (!scope) {\n    return eventObject\n  }\n  const isShape = !is.unit(eventObject) && typeof eventObject === 'object'\n  const events = isShape ? eventObject : {event: eventObject}\n\n  return React.useMemo(() => {\n    if (is.unit(eventObject)) {\n      //@ts-expect-error\n      return scopeBind(eventObject, {scope})\n    }\n    const shape = Array.isArray(eventObject) ? [] : ({} as any)\n    for (const key in eventObject) {\n      shape[key] = scopeBind(eventObject[key], {scope})\n    }\n    return shape\n  }, [scope, ...Object.keys(events), ...Object.values(events)])\n}\n\nexport function useGateBase<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  scope?: Scope,\n) {\n  const {open, close, set} = useUnitBase(\n    {\n      open: GateComponent.open,\n      close: GateComponent.close,\n      set: GateComponent.set,\n    },\n    scope,\n  )\n  const ForkedGate = React.useMemo(\n    () =>\n      ({\n        open,\n        close,\n        set,\n      } as Gate<Props>),\n    [GateComponent, open],\n  )\n\n  const propsRef = React.useRef<{value: any; count: number}>({\n    value: null,\n    count: 0,\n  })\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.open(propsRef.current.value)\n    return () => ForkedGate.close(propsRef.current.value) as any\n  }, [ForkedGate])\n  if (!shallowCompare(propsRef.current.value, props)) {\n    propsRef.current.value = props\n    propsRef.current.count += 1\n  }\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.set(propsRef.current.value)\n  }, [propsRef.current.count])\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\n","import React from 'react'\nimport {Scope} from 'effector'\nimport {throwError} from './throw'\n\nconst ScopeContext = React.createContext(null as Scope | null)\nexport const {Provider} = ScopeContext\nexport function getScope(forceScope?: boolean) {\n  const scope = React.useContext(ScopeContext)\n  if (forceScope && !scope)\n    throwError('No scope found, consider adding <Provider> to app root')\n  return scope as Scope\n}\n","import {Event, Store} from 'effector'\nimport {\n  useStoreBase,\n  useStoreMapBase,\n  useListBase,\n  useUnitBase,\n  useEventBase,\n  useGateBase,\n} from './apiBase'\nimport {getScope} from './scope'\nimport type {Gate} from './index.h'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(\n  event: Event<T>,\n  opts?: {forceScope?: boolean},\n): (payload: T) => T {\n  const scope = getScope(opts?.forceScope)\n\n  return useEventBase(event, scope)\n}\n\nexport function useStore<State>(\n  store: Store<State>,\n  opts?: {forceScope?: boolean},\n): State {\n  return useStoreBase(store, getScope(opts?.forceScope))\n}\n\nexport function useUnit(shape, opts?: {forceScope?: boolean}) {\n  return useUnitBase(shape, getScope(opts?.forceScope))\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n        defaultValue?: Result\n        forceScope?: boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  return useStoreMapBase(\n    [configOrStore, separateFn],\n    getScope(configOrStore?.forceScope),\n  )\n}\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  opts?: {forceScope?: boolean},\n): React.ReactNode {\n  return useListBase(list, renderItem, getScope(opts?.forceScope))\n}\n\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  opts?: {forceScope?: boolean},\n) {\n  return useGateBase(GateComponent, props, getScope(opts?.forceScope))\n}\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef, Stack} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  failReason?: unknown\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n  meta?: Record<string, any> | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n      meta,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope | void | null) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\n/** Introspection api internals */\ntype Inspector = (stack: Stack, local: Local) => void\nlet inspector: Inspector\nexport const setInspector = (newInspector: Inspector) => {\n  inspector = newInspector\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void | null\n  stack?: Stack | void\n  meta?: Record<string, any> | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  let meta: Record<string, any> | void\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    meta = unit.meta\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n        meta,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n      meta,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (inspector) {\n      inspector(stack, local)\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      const forkPage = getForkPage(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem('child', page, nextNode, stack, finalValue, forkPage)\n      })\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'warnSerialize'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.warnSerializeNode,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nconst noopParser = (x: any) => x\n\nexport const initRefInScope = (\n  scope: Scope,\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  if (refsMap[sourceRef.id]) return\n  const sid = sourceRef.sid\n  const serialize = sourceRef?.meta?.serialize\n  const parser =\n    scope.fromSerialize && serialize !== 'ignore'\n      ? serialize?.read || noopParser\n      : noopParser\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n    meta: sourceRef.meta,\n  }\n\n  if (ref.id in scope.values.idMap) {\n    ref.current = scope.values.idMap[ref.id]\n  } else if (sid && sid in scope.values.sidMap && !(sid in scope.sidIdMap)) {\n    ref.current = parser(scope.values.sidMap[sid])\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n    local.failReason = err\n  }\n}\n","import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : (unit as any).toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    // @ts-expect-error\n    if (fn) return fn(template, ...args)\n  }\n}\n","import type {Template} from '../forest/index.h'\nimport type {Store, Event, CommonUnit, Effect, Domain} from './unit.h'\nimport type {Subscriber, Config, Cmd, Kind} from './index.h'\n\nimport {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot, reportDeclaration} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: CommonUnit,\n  target: CommonUnit,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: Kind, unit: any, rawConfig: any) => {\n  const config = flattenConfig(rawConfig)\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const {sid = null, named = null, domain = null, parent = domain} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (\n  event: Event<any>,\n  op: 'map' | 'filterMap' | 'filter',\n  fn: Function,\n  node: Cmd[],\n) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = (fn as unknown as {fn: Function}).fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName} → *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    deprecate(!isPure, 'unit call from pure function', 'operators like sample')\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  const finalEvent = Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(config.actualOp || EVENT, event, config),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      //@ts-expect-error\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n  if (config?.domain) {\n    config.domain.hooks.event(finalEvent)\n  }\n  setMeta(finalEvent, 'id', finalEvent.graphite.id)\n  reportDeclaration(finalEvent.graphite)\n  return finalEvent\n}\nfunction on<State>(\n  store: Store<State>,\n  methodName: string,\n  nodeSet: CommonUnit | CommonUnit[],\n  fn: Function,\n) {\n  assertNodeSet(nodeSet, methodName, 'first argument')\n  assert(isFunction(fn), 'second argument should be a function')\n  deprecate(\n    !getMeta(store, 'derived'),\n    `${methodName} in derived store`,\n    `${methodName} in store created via createStore`,\n  )\n  forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n    store.off(trigger)\n    getSubscribers(store).set(\n      trigger,\n      createSubscription(updateStore(trigger, store, 'on', callARegStack, fn)),\n    )\n  })\n  return store\n}\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const config = flattenConfig(props)\n  const plainState = createStateRef(defaultState)\n  const updates = createEvent({named: 'updates', derived: true})\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      forEach(units, unit =>\n        on(store, '.reset', unit, () => store.defaultState),\n      )\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      return on(store, '.on', nodeSet, fn)\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any, prevArg?: any) => any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        derived: true,\n        // @ts-expect-error some mismatch in config types\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return (eventOrFn as CommonUnit).watch((payload: any) =>\n        fn(store.getState(), payload),\n      )\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, config)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta: {\n      ...meta,\n      defaultState,\n    },\n    regional: true,\n  })\n  setMeta(store, 'id', store.graphite.id)\n  setMeta(store, 'rootStateRefId', plainStateId)\n  const serializeMeta = getMeta(store, 'serialize')\n  const derived = getMeta(store, 'derived')\n  const ignored = serializeMeta === 'ignore'\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n  }\n  if (!sid && !ignored && !derived) {\n    setMeta(store, 'warnSerialize', true)\n  }\n  assert(\n    derived || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  if (config?.domain) {\n    config.domain.hooks.store(store)\n  }\n\n  if (!derived) {\n    store.reinit = createEvent<void>({\n      named: 'reinit',\n    })\n    store.reset(store.reinit)\n  }\n\n  plainState.meta = store.graphite.meta\n\n  reportDeclaration(store.graphite)\n\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => [...list] : (obj: any) => ({...obj})\n  const defaultState: Record<string, any> = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  /**\n   * Soft store reading is required for\n   * setting target store as inited in scope\n   * for preventing retriggering issues\n   **/\n  const softReader = mov({\n    store: storeStateRef,\n    to: 'b',\n    priority: 'read',\n  })\n  softReader.data.softRead = true\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && userFnCall(),\n    softReader,\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args: any[]) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","import type {Defer} from './unit.h'\n\nexport function createDefer(): Defer {\n  const result = {} as Defer\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(() => {})\n  return result\n}\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  assertNodeSet(units, 'merge', 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n","import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any[]) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  let filter\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, SAMPLE)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    SAMPLE,\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batched,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batched: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  // @ts-expect-error\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, method, 'target')\n    assertTarget(method, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      // @ts-expect-error\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      // @ts-expect-error\n      clock,\n      clockState,\n      method,\n    )\n    filterNodes = [...readAndFilter(hasFilter), ...readAndFilter(filterRef)]\n  }\n  const [sourceRef, hasSource] = syncSourceState(\n    // @ts-expect-error\n    source,\n    target,\n    clock,\n    clockState,\n    method,\n  )\n  const jointNode = createLinkNode(\n    // @ts-expect-error\n    clock,\n    target,\n    [\n      applyTemplate('sampleSourceLoader'),\n      mov({from: STACK, target: clockState}),\n      ...readAndFilter(hasSource),\n      read(sourceRef, true, batched),\n      ...filterNodes,\n      read(clockState),\n      filterType === 'fn' && userFnCall((src, _, {a}) => filter(src, a), true),\n      fn && userFnCall(callStackAReg),\n      applyTemplate('sampleSourceUpward', isUpward),\n    ],\n    method,\n    fn,\n  )\n  // @ts-expect-error\n  own(source, [jointNode])\n  Object.assign(jointNode.meta, metadata, {joint: true})\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource] as const\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\nimport type {Unit} from '../index.h'\n\n/** bind event to scope */\nexport function scopeBind(\n  unit: Unit,\n  {scope, safe}: {scope?: Scope; safe?: true} = {},\n) {\n  assert(\n    scope || forkPage || safe,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : (params: any) => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n","export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n","import type {Kind, Unit} from './index.h'\nimport type {Domain, Effect, Event, Scope, Store} from './unit.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {getMeta} from './getter'\n\nexport const unit = (obj: unknown): obj is Unit<any> =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: Kind) => (obj: unknown) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: unknown) => value is Store<unknown>\nexport const event = is(EVENT) as (value: unknown) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: unknown,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value: unknown) => value is Domain\nexport const scope = is(SCOPE) as (value: unknown) => value is Scope\nexport const attached = (unit: unknown) =>\n  effect(unit) && getMeta(unit, 'attached') === true\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\nexport const nextEffectID = idCount()\n","import type {Template} from '../forest/index.h'\nimport type {NodeUnit, Node, ID} from './index.h'\nimport {getParent, getGraph} from './getter'\nimport {createNode} from './createNode'\n\ntype DeclarationSourceReporter = (\n  node: Node | 'region',\n  regionStack: RegionStack | null,\n) => void\n\nlet reporter: DeclarationSourceReporter\n\nexport const setGraphInspector = (fn: DeclarationSourceReporter) => {\n  reporter = fn\n}\n\ntype RegionStack = {\n  id: ID\n  parent: RegionStack | null\n  value: any\n  template: Template | null\n  sidRoot?: string\n  meta:\n    | Record<string, unknown>\n    | {\n        type: 'factory'\n        sid?: string\n        name?: string\n        loc: unknown\n        method?: string\n      }\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const reportDeclaration = (node: Node | 'region') => {\n  if (reporter) {\n    reporter(node, regionStack)\n  }\n}\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion<T = void>(unit: NodeUnit, cb: () => T): T {\n  const meta = getGraph(unit).meta || {}\n\n  regionStack = {\n    id: getGraph(unit).id,\n    parent: regionStack,\n    value: unit,\n    template: meta.template || readTemplate(),\n    sidRoot: meta.sidRoot || (regionStack && regionStack.sidRoot),\n    meta: meta,\n  }\n  try {\n    return cb()\n  } finally {\n    reportDeclaration('region')\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const factoryRootNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), sid, name, loc, method, type: 'factory'},\n  })\n\n  return withRegion(factoryRootNode, fn)\n}\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","import type {Stack} from './index.h'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n  Stack,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = <Type extends 'compute' | 'mov'>(\n  type: Type,\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: {\n    id: string\n    type: Type\n    data: any\n    order?: {\n      priority: BarrierPriorityTag\n      barrierID?: number\n    }\n  } = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data: any, scope: LocalValues, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>(\n  fn: (data: any, scope: LocalValues, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const method = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, method, '\"from\"')\n  assertNodeSet(to, method, '\"to\"')\n  assertTarget(method, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: method, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n","import type {Unit, Stack} from './index.h'\nimport type {Effect, Scope} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add, removeItem} from './collection'\nimport {flattenConfig} from './config'\nimport {nextEffectID} from './id'\n\ntype RunnerData<Params, Done, Fail> = {\n  params: Params\n  req: {\n    rs(data: Done): void\n    rj(data: Fail): void\n  }\n  args?: [params: Params, computedParams: any] | [params: Params]\n  handler?: Function\n}\n\nexport function createEffect<Params, Done, Fail = Error>(\n  nameOrConfig: any,\n  maybeConfig: any = {},\n): Effect<Params, Done, Fail> {\n  const config = flattenConfig(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    {...maybeConfig, actualOp: EFFECT},\n  ) as unknown as Effect<Params, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createEvent({\n    named: 'finally',\n    derived: true,\n  }))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({\n      status,\n      params,\n      result,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({\n      status,\n      params,\n      error,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: {result: Done}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: {error: Fail}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd: RunnerData<Params, Done, Fail>, scope_: any, stack) => {\n          let handler: Function = scope_.handler\n          const scope = getForkPage(stack)\n          if (scope) {\n            const scopeHandler =\n              scope.handlers.unitMap.get(instance) ||\n              scope.handlers.sidMap[instance.sid!]\n            if (scopeHandler) handler = scopeHandler\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        (\n          {\n            params,\n            req,\n            handler,\n            args = [params],\n          }: RunnerData<Params, Done, Fail> & {handler: Function},\n          _,\n          stack,\n        ) => {\n          const scopeRef = createScopeRef(stack)\n          const onResolve = onSettled(\n            params,\n            req,\n            true,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const onReject = onSettled(\n            params,\n            req,\n            false,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd: RunnerData<Params, Done, Fail> = getParent(stack)\n          ? {params, req: {rs(data: Done) {}, rj(data: Fail) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        if (!stack.meta) {\n          stack.meta = {fxID: nextEffectID()}\n        }\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n          meta: stack.meta,\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  //@ts-expect-error\n  instance.create = (params: Params) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n    }\n    launch({\n      target: instance,\n      params: payload,\n      scope: forkPage,\n    })\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {\n    serialize: 'ignore',\n    named: (getMeta(instance, 'name') || instance.graphite.id) + '.inFlight',\n  })\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1)\n    .map({\n      // @ts-expect-error\n      fn: x => x,\n      named: 'inFlight',\n    }))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  if (config?.domain) {\n    config.domain.hooks.effect(instance)\n  }\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const createScopeRef = (stack: Stack) => {\n  const scope = getForkPage(stack)\n  const scopeRef = {ref: scope}\n  if (scope) add(scope.activeEffects, scopeRef)\n  return scopeRef\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): void\n      rj(_: any): void\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n    scopeRef: {ref: Scope | void},\n  ) =>\n  (data: any) => {\n    if (scopeRef.ref) removeItem(scopeRef.ref.activeEffects, scopeRef)\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      // WARN! Will broke forest pages as they arent moved to new scope\n      page: stack.page,\n      scope: scopeRef.ref,\n      meta: stack.meta,\n    })\n  }\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n"],"names":["Symbol","require","module","exports","array","iteratee","index","length","result","Array","string","split","getRawTag","objectToString","symToStringTag","toStringTag","undefined","value","Object","start","end","arrayMap","isArray","isSymbol","symbolProto","prototype","symbolToString","toString","baseToString","call","baseSlice","castSlice","hasUnicode","stringToArray","methodName","strSymbols","chr","charAt","trailing","join","slice","freeGlobal","global","objectProto","hasOwnProperty","nativeObjectToString","isOwn","tag","unmasked","e","reHasUnicode","RegExp","test","freeSelf","self","root","Function","asciiToArray","unicodeToArray","rsAstralRange","rsAstral","rsCombo","rsFitz","rsNonAstral","rsRegional","rsSurrPair","reOptMod","rsOptVar","rsSeq","rsSymbol","reUnicode","match","upperFirst","toLowerCase","baseGetTag","isObjectLike","createCaseFirst","k","is","a","b","l","useState","m","useEffect","n","useLayoutEffect","p","useDebugValue","r","getSnapshot","d","f","u","window","document","createElement","inst","c","g","useSyncExternalStore","h","q","t","useRef","v","useMemo","w","useSyncExternalStoreWithSelector","current","hasValue","defaultProps","underline","Anchor","polymorphicFactory","props","ref","className","unstyled","others","useProps","React","Text","component","cx","classes","mod","__staticSelector","displayName","varsResolver","createVarsResolver","theme","_ref","radius","color","gradient","variant","size","autoContrast","colors","variantColorResolver","primaryColor","getSize","getRadius","background","border","getThemeColor","Badge","_props","classNames","style","styles","vars","leftSection","rightSection","children","fullWidth","circle","getStyles","useStyles","name","Box","block","InlineInput","forwardRef","__stylesApiProps","label","description","id","disabled","error","labelPosition","__vars","getFontSize","htmlFor","Input","Description","__inheritStyles","Error","RadioGroupProvider","useRadioGroupContext","createOptionalContext","InputsGroupFieldset","role","ctx","useInputWrapperContext","labelId","describedBy","RadioGroup","factory","defaultValue","onChange","wrapperProps","_name","useId","_value","setValue","useUncontrolled","finalValue","event","currentTarget","Wrapper","labelElement","RadioIcon","xmlns","fill","viewBox","width","rem","height","cy","iconColor","parsedColor","parseThemeColor","outlineColor","isThemeColor","shade","getContrastColor","Radio","_ctx$size","_rest$name","icon","Icon","rootRef","contextSize","componentSize","styleProps","rest","extractStyleProps","uuid","contextProps","checked","focusable","type","Group","TableProvider","useTableContext","createSafeContext","getDataAttributes","options","data","columnBorder","withColumnBorders","rowBorder","withRowBorders","striped","highlightOnHover","captionSide","stickyHeader","tableElement","element","toUpperCase","Component","TableTh","TableTd","TableTr","TableThead","TableTbody","TableTfoot","TableCaption","TableDataRenderer","caption","head","map","item","key","body","row","rowIndex","foot","_","minWidth","scrollContainer","TableScrollContainer","rootSelector","ScrollArea","offsetScrollbars","verticalSpacing","layout","horizontalSpacing","borderColor","stripedColor","highlightOnHoverColor","stickyHeaderOffset","table","getSpacing","Table","withTableBorder","Td","Th","Tr","Thead","Tbody","Tfoot","Caption","ScrollContainer","DataRenderer","o","mov","store","stateRef","to","run","fn","unshift","node","meta","watchOp","graphite","additionalLinks","s","push","indexOf","splice","S","parent","family","owners","x","unit","N","stale","justSubscribed","scope","i","effect","j","keys","values","storeKeys","eventKeys","eventValues","cbCaller","compute","priority","batch","forEach","y","V","includes","M","U","forceScope","R","K","E","stateReader","getState","Provider","B","from","source","target","child","regional","arguments","Se","links","le","pe","seq","next","T","he","we","H","nt","et","params","defer","page","stack","G","Qe","L","tt","isRoot","currentPage","isWatch","rt","isPure","at","Ke","idx","reg","fail","order","barrierID","fullID","Ze","has","add","Xe","delete","P","st","pt","softRead","We","dt","J","pure","safe","mt","filter","ft","fxCount","storeChange","warnSerializeNode","X","Q","fullName","path","concat","shortName","ze","or","and","Me","be","handlers","_len","_key","gt","_len2","_key2","se","template","lt","create","assign","$t","actualOp","watch","Mt","zt","Le","qe","filterMap","_e","$e","prepend","wt","xt","domain","hooks","ye","Ce","xe","off","set","kt","jt","Oe","Be","named","derived","subscribers","Map","updates","defaultState","setState","reset","_len3","_key3","on","get","Ie","He","W","noInit","defaultConfig","updateFilter","state","Pe","Re","sid","reinit","_len4","_key4","Z","Ct","req","Promise","rs","rj","catch","Nt","Dt","_len6","_key6","clock","greedy","Rt","te","observable","getMeta","setMeta","compositeName","Y","kind","ee","re","ae","ne","__proto__","attached","oe","removeItem","deprecate","console","fe","idCount","de","ue","ce","readTemplate","ve","sidRoot","own","flat","je","assertNodeSetItem","assertNodeSet","Ae","callStackAReg","_ref13","_ref14","callARegStack","_ref15","_ref16","callStack","_ref17","Ne","cmd","De","_ref18","Fe","_ref19","Ee","_ref20","calc","read","Te","_ref21","_ref22","addRefOp","before","Ue","Ve","merge","Ye","Ge","Je","first","last","deleteMin","pushFirstHeapItem","Set","getPageForRef","getPageRef","ct","initRefInScope","serialize","fromSerialize","idMap","sidMap","sidIdMap","field","tryRun","failReason","ht","removeFromNode","yt","clearNodeNormalized","pop","bt","clear","vt","deep","ownerSet","history","events","effects","stores","domains","unsubscribe","createLinkNode","op","watchUnit","initUnit","unitId","config","thru","getType","subscribe","nativeTemplate","deriveEvent","updateStore","storeCombination","_ref23","defaultShape","_ref24","fx","fieldErrorMessage","createSampling","Et","Ft","$","_ref25","joint","_ref26","syncSourceState"],"sourceRoot":""}